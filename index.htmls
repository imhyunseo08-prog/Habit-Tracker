<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Habit Tracker v91 - Optimized</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    body { font-family: -apple-system, sans-serif; background: #F8FAFC; margin: 0; overflow-x: hidden; -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .scroll-container { display: flex; gap: 4px; overflow-x: auto; flex-direction: row-reverse; flex: 1; padding: 1px 0 20px 0; -webkit-overflow-scrolling: touch; }
    .chart-wrapper { position: relative; height: 160px; width: 100%; display: flex; align-items: flex-end; padding-bottom: 20px; }
    .chart-container { position: relative; height: 100%; flex: 1; min-width: 0; }
    .chk-btn { transition: transform 0.1s ease; position: relative; border: 2px solid transparent; }
    .chk-btn.active { background-color: #6366f1 !important; }
    .theme-card { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; touch-action: pan-y; position: relative; transition: transform 0.2s, box-shadow 0.2s; border-left: 4px solid #6366f1; }
    .theme-card.priority { border-left: 4px solid #f59e0b; box-shadow: 0 2px 16px rgba(245,158,11,0.18), 0 0 0 1.5px #fde68a; }
    .blackboard-container { position: relative; width: 100%; transition: all 0.3s ease; }
    .blackboard-container.fullscreen { position: fixed; inset: 0; z-index: 9000; background: #334155; padding: 10px; height: 100vh; display: flex; flex-direction: column; }
    .blackboard-area { background-color: #0f172a; border: 8px solid #1e293b; border-radius: 20px; height: 400px; position: relative; overflow: hidden; touch-action: none; box-shadow: inset 0 0 40px rgba(0,0,0,0.5); flex: 1; }
    .board-content-wrapper { width: 5000px; height: 5000px; position: absolute; top: 0; left: 0; transform-origin: 0 0; background-color: #334155; border: 4px dashed rgba(255,255,255,0.2); box-sizing: content-box; }
    .drawing-canvas { position: absolute; top: 0; left: 0; z-index: 1; touch-action: none; background: transparent; }
    .memo-card { position: absolute; padding: 12px; background: #fef08a; color: #854d0e; font-weight: bold; font-size: 14px; border-radius: 4px; box-shadow: 2px 4px 6px rgba(0,0,0,0.3); cursor: grab; user-select: none; word-break: break-all; touch-action: none; z-index: 10; white-space: pre-wrap; display: flex; flex-direction: column; }
    .memo-card.active-border { border: 2px solid #6366f1; }
    .memo-card.locked { border: 2px solid #ef4444; cursor: default; }
    .resize-h { position: absolute; right: -8px; top: 0; width: 16px; height: 100%; cursor: ew-resize; z-index: 15; }
    .resize-v { position: absolute; bottom: -8px; left: 0; width: 100%; height: 16px; cursor: ns-resize; z-index: 15; }
    .memo-toolbar { position: absolute; bottom: calc(100% + 10px); left: 50%; transform: translateX(-50%); background: white; border-radius: 8px; padding: 4px; display: flex; gap: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 50; white-space: nowrap; }
    .memo-toolbar::after { content: ''; position: absolute; top: 100%; left: 50%; margin-left: -6px; border-width: 6px; border-style: solid; border-color: white transparent transparent transparent; }
    .tool-btn { padding: 4px 8px; font-size: 12px; font-weight: bold; border-radius: 4px; background: #f1f5f9; color: #475569; }
    .tool-btn.danger { color: #ef4444; background: #fee2e2; }
    .tool-btn.active { color: white; background: #6366f1; }
    .board-controls { margin-top: 10px; padding: 8px 12px; background: #ffffff; border-radius: 20px; display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
    .color-swatch { width: 20px; height: 20px; border-radius: 50%; border: 1.5px solid #e2e8f0; cursor: pointer; flex-shrink: 0; }
    .color-swatch.selected { transform: scale(1.2); border-color: #6366f1; }
    #external-modal { position: fixed; inset: 0; z-index: 9999; display: none; align-items: center; justify-content: center; padding: 24px; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); }
    #external-modal.active { display: flex; }
    .collapsible-content { overflow: hidden; }
    .collapsible-content.collapsed { max-height: 0 !important; opacity: 0; pointer-events: none; }
    .collapsible-content.expanded { max-height: 9999px; opacity: 1; transition: max-height 0.35s ease-out, opacity 0.2s ease; }
    .expand-down { transform-origin: top center; }
    .goal-input { width: 100%; background: #f1f5f9; border: 1px solid transparent; border-radius: 12px; padding: 10px 14px; font-size: 18px; font-weight: 800; color: #1e293b; outline: none; transition: all 0.2s; white-space: pre-wrap; display: block; overflow: visible; height: auto; min-height: 48px; }
    .goal-input:focus { border-color: #6366f1; background: white; }
    .goal-input:disabled { background: transparent; border-color: transparent; padding: 0; cursor: default; min-height: 0; }
    .goal-label { font-size: 11px; font-weight: 800; color: #94a3b8; text-transform: uppercase; margin-bottom: 8px; display: block; }
    .goal-item-row { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
    .category-depth-0 { border: 2px solid #c7d2fe; border-radius: 1.8rem; background: #fff; margin-bottom: 1rem; overflow: hidden; box-shadow: 0 2px 12px rgba(99,102,241,0.09); }
    .category-depth-1 { border: 2px solid #dde3ff; border-radius: 1.3rem; background: #f8faff; margin-bottom: 0.6rem; overflow: hidden; box-shadow: 0 1px 6px rgba(99,102,241,0.06); }
    .category-depth-2 { border: 1.5px solid #ede9fe; border-radius: 1rem; background: #f5f3ff; margin-bottom: 0.5rem; overflow: hidden; }
    .category-depth-3 { border: 1.5px dashed #ddd6fe; border-radius: 0.8rem; background: #faf5ff; margin-bottom: 0.4rem; overflow: hidden; }
    .category-hidden { opacity: 0.45; filter: grayscale(0.5); }
    .category-header-0 { display: flex; align-items: center; justify-content: space-between; padding: 1rem 1.2rem; cursor: pointer; background: linear-gradient(90deg,#eef2ff 0%,#f8faff 100%); border-bottom: 1.5px solid #d4d9ff; }
    .category-header-1 { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; cursor: pointer; background: #edf0ff; border-bottom: 1px solid #dde3ff; }
    .category-header-2 { display: flex; align-items: center; justify-content: space-between; padding: 0.6rem 0.9rem; cursor: pointer; background: #f3f0ff; border-bottom: 1px solid #e8e2fd; }
    .category-header-3 { display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0.8rem; cursor: pointer; background: #f9f6ff; }
    .category-body-0 { padding: 0.8rem; background: #f6f8ff; }
    .category-body-1 { padding: 0.6rem; background: #f4f6ff; }
    .category-body-2 { padding: 0.5rem; background: #f6f4ff; }
    .category-body-3 { padding: 0.4rem; background: #fbf8ff; }
    .card-elevated { box-shadow: 0 2px 16px rgba(0,0,0,0.10), 0 0 0 1.5px #e2e8f0; }
    .category-chart-card { border-left: 4px solid #a78bfa; }
    .theme-select-fixed { flex-shrink: 0; width: 90px; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .analysis-panel-wrap { overflow: hidden; position: relative; touch-action: pan-y; }
    .analysis-panel-inner { display: flex; transition: transform 0.35s cubic-bezier(.4,0,.2,1); will-change: transform; }
    .analysis-panel-page { flex: 0 0 100%; min-width: 0; }
    .analysis-dot { width: 6px; height: 6px; border-radius: 50%; background: #cbd5e1; transition: background 0.2s; }
    .analysis-dot.active { background: #6366f1; }
    .notebox { background: #fff; border-radius: 1.5rem; box-shadow: 0 2px 12px rgba(99,102,241,0.07), 0 0 0 1.5px #e2e8f0; overflow: hidden; }
    .notebox-item { display: flex; align-items: center; gap: 8px; padding: 8px 14px; border-bottom: 1px solid #f1f5f9; }
    .notebox-item:last-child { border-bottom: none; }
    .notebox-item input { flex: 1; background: transparent; border: none; outline: none; font-size: 14px; font-weight: 600; color: #334155; }
    .notebox-item input::placeholder { color: #cbd5e1; }
    .notebox-item.done input { text-decoration: line-through; color: #94a3b8; }
    .notebox-add { display: flex; align-items: center; gap: 8px; padding: 8px 14px; }
    .notebox-add input { flex: 1; background: transparent; border: none; outline: none; font-size: 14px; color: #334155; }
    .notebox-add input::placeholder { color: #d1d5db; }
  </style>
</head>
<body>
  <div id="root"></div>
  <div id="external-modal">
    <div class="bg-white w-full max-w-sm rounded-[2.5rem] p-8 shadow-2xl">
      <h3 id="modal-title" class="text-2xl font-black mb-6 text-slate-800">수정</h3>
      <textarea id="common-input" class="w-full bg-slate-100 p-4 rounded-2xl mb-8 outline-none font-bold text-lg min-h-[120px]" placeholder="내용 입력..." autocomplete="off"></textarea>
      <div class="flex gap-3">
        <button onclick="closeModal()" class="flex-1 py-4 bg-slate-200 text-slate-600 rounded-2xl font-bold">취소</button>
        <button id="modal-submit-btn" class="flex-1 py-4 bg-indigo-600 text-white rounded-2xl font-bold">확인</button>
      </div>
    </div>
  </div>
  <script>
    const e = React.createElement;
    const { useState, useEffect, useRef, useCallback, memo, useMemo } = React;
    const getInitialData = (k, f) => { const s = localStorage.getItem(k); return s ? JSON.parse(s) : f; };
    const getTodayStr = () => { const d = new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; };

    const createOrUpdateChart = (chartRef, ctx, configFactory) => {
      const cfg = configFactory();
      if (chartRef.current) { chartRef.current.config.type = cfg.type; chartRef.current.config.data = cfg.data; chartRef.current.config.options = cfg.options; if (cfg.plugins) chartRef.current.config.plugins = cfg.plugins; chartRef.current.update('none'); }
      else { chartRef.current = new Chart(ctx, cfg); }
    };

    const DonutGauge = memo(({ percent }) => {
      const canvasRef = useRef(null); const chartRef = useRef(null);
      const dp = Math.min(100, Math.max(0, percent));
      useEffect(() => {
        if (!canvasRef.current) return;
        createOrUpdateChart(chartRef, canvasRef.current.getContext('2d'), () => ({ type: 'doughnut', data: { datasets: [{ data: [dp, 100-dp], backgroundColor: ['#6366f1','#f1f5f9'], borderWidth: 0, cutout: '75%' }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { tooltip: { enabled: false }, legend: { display: false } }, animation: { duration: 300 } } }));
      }, [dp]);
      return e('div', { className: 'relative w-24 h-24' }, e('canvas', { ref: canvasRef }), e('div', { className: 'absolute inset-0 flex items-center justify-center' }, e('span', { className: 'text-lg font-black text-slate-800' }, `${Math.round(dp)}%`)));
    });

    const AnalysisChart = memo(({ themes, habits, dates, goals, priorityThemes }) => {
      const canvasRef = useRef(null); const chartRef = useRef(null);
      const allGoalItems = useMemo(() => goals.flatMap(g => g.targetItems), [goals]);
      const allGoalDates = useMemo(() => { const set = new Set(); goals.forEach(g => { const s = new Date(g.startDate), en = new Date(g.endDate); if (isNaN(s)||isNaN(en)) return; let c = new Date(s); while(c<=en){ set.add(`${c.getFullYear()}-${String(c.getMonth()+1).padStart(2,'0')}-${String(c.getDate()).padStart(2,'0')}`); c.setDate(c.getDate()+1); } }); return Array.from(set); }, [goals]);
      useEffect(() => {
        if (!canvasRef.current) return;
        const hs = themes.map(t => { const th=habits.filter(h=>h.theme===t); if(!th.length) return 0; const tc=th.reduce((a,h)=>a+dates.filter(d=>h.checks[d]).length,0); return Math.round((tc/(th.length*dates.length))*100); });
        const ps = themes.map(t => { const isT=allGoalItems.some(it=>it.theme===t); if(!isT) return null; const th=habits.filter(h=>h.theme===t); if(!th.length||!allGoalDates.length) return 0; const tc=th.reduce((a,h)=>a+allGoalDates.filter(d=>h.checks[d]).length,0); return Math.round((tc/(th.length*allGoalDates.length))*100); });
        const tl = themes.map(t => { const items=allGoalItems.filter(it=>it.theme===t); return items.length?Math.max(...items.map(i=>i.target)):null; });
        const barColors = themes.map(t => (priorityThemes&&priorityThemes.has(t))?'#f59e0b':'#6366f1');
        createOrUpdateChart(chartRef, canvasRef.current.getContext('2d'), () => ({ type: 'bar', data: { labels: themes, datasets: [{ label:'전체', data:hs, backgroundColor:barColors, borderRadius:6, barThickness:20, order:3 }, { label:'기간', data:ps, backgroundColor:'transparent', borderColor:'#ef4444', borderWidth:2, borderRadius:6, barThickness:20, grouped:false, order:2 }, { label:'목표치', data:tl, type:'line', borderColor:'#ef4444', borderWidth:2, pointStyle:'dash', pointRadius:(ctx)=>(ctx.dataset.data[ctx.dataIndex]===null?0:12), showLine:false, order:1 }] }, options: { responsive:true, maintainAspectRatio:false, animation:false, plugins:{ legend:{display:false} }, scales:{ y:{beginAtZero:true,max:100,ticks:{stepSize:20,font:{size:10}}}, x:{grid:{display:false},ticks:{font:{size:9,weight:'bold'},maxRotation:45,minRotation:45}} } } }));
      }, [themes, habits, dates, allGoalDates, allGoalItems, priorityThemes]);
      return e('canvas', { ref: canvasRef });
    });

    const CategoryAnalysisChart = memo(({ visibleCats, habits, dates, getCategoryThemes }) => {
      const canvasRef = useRef(null); const chartRef = useRef(null);
      useEffect(() => {
        if (!canvasRef.current) return;
        const cats = visibleCats.filter(c => getCategoryThemes(c).length > 0);
        if (!cats.length) { if (chartRef.current) { chartRef.current.destroy(); chartRef.current = null; } return; }
        const labels = cats.map(c => c.name);
        const scores = cats.map(c => {
          const catThemes = getCategoryThemes(c);
          if (!catThemes.length) return 0;
          const maxScore = catThemes.length * 100;
          const total = catThemes.reduce((acc, tName) => { const th=habits.filter(h=>h.theme===tName); if(!th.length) return acc; return acc+dates.reduce((da,d)=>da+Math.round((th.filter(h=>h.checks[d]).length/th.length)*100),0); }, 0);
          return Math.round((total/(maxScore*dates.length))*100);
        });
        createOrUpdateChart(chartRef, canvasRef.current.getContext('2d'), () => ({ type:'bar', data:{ labels, datasets:[{ label:'카테고리 달성률', data:scores, backgroundColor:'#a78bfa', borderRadius:6, barThickness:20 }] }, options:{ responsive:true, maintainAspectRatio:false, animation:false, plugins:{ legend:{display:false} }, scales:{ y:{beginAtZero:true,max:100,ticks:{stepSize:20,font:{size:10}}}, x:{grid:{display:false},ticks:{font:{size:9,weight:'bold'},maxRotation:45,minRotation:45}} } } }));
      }, [visibleCats, habits, dates, getCategoryThemes]);
      return e('canvas', { ref: canvasRef });
    });

    const TrendChart = memo(({ data, labels, color, targetValue, averageValue, hasGoal, goalDates, periodScore, maxY }) => {
      const canvasRef = useRef(null); const chartRef = useRef(null);
      useEffect(() => {
        if (!canvasRef.current) return;
        const yMax = maxY||115;
        const datasets = [
          { label:'실제', data, borderColor:color, backgroundColor:color==='#6366f1'?'rgba(99,102,241,0.2)':'rgba(167,139,250,0.15)', borderWidth:2, pointRadius:0, fill:true, tension:0.4, order:1 },
          { label:'평균', data:new Array(data.length).fill(averageValue), borderColor:color, borderWidth:1.5, pointRadius:0, fill:false, order:2 }
        ];
        if (hasGoal) {
          datasets.push({ label:'목표치', data:labels.map(d=>goalDates.includes(d)?targetValue:null), borderColor:'#ef4444', borderWidth:1.5, pointRadius:0, fill:true, backgroundColor:'rgba(239,68,68,0.08)', tension:0, order:10 });
          datasets.push({ label:'기간달성', data:labels.map(d=>goalDates.includes(d)?periodScore:null), borderColor:'#10b981', borderWidth:1.5, borderDash:[3,3], pointRadius:0, fill:false, order:5 });
        }
        createOrUpdateChart(chartRef, canvasRef.current.getContext('2d'), () => ({ type:'line', data:{ labels:labels.map(l=>l.split('-').slice(1).join('.')), datasets }, options:{ responsive:true, maintainAspectRatio:false, animation:false, layout:{padding:{right:45}}, plugins:{legend:{display:false}}, scales:{ x:{display:true,grid:{display:false},ticks:{font:{size:8},maxRotation:0,minRotation:0}}, y:{display:false,min:0,max:yMax} } }, plugins:[{ id:'endLabels', afterDatasetsDraw(chart){ const {ctx}=chart; chart.data.datasets.forEach((ds,i)=>{ const meta=chart.getDatasetMeta(i); if(meta.hidden||ds.label==='실제') return; let li=-1; for(let j=ds.data.length-1;j>=0;j--){ if(ds.data[j]!==null){li=j;break;} } if(li===-1) return; const pt=meta.data[li]; if(pt){ ctx.fillStyle=ds.borderColor; ctx.font='bold 9px sans-serif'; ctx.textAlign='left'; ctx.fillText(`${ds.label==='기간달성'?'달성:':''}${ds.data[li]}%`,pt.x+4,pt.y+3); } }); } }] }));
      }, [data, labels, color, targetValue, averageValue, hasGoal, goalDates, periodScore, maxY]);
      return e('div', { className:'chart-container' }, e('canvas', { ref:canvasRef }));
    });

    const HabitItem = memo(({ habit, dates, onAction }) => {
      const rangeCount = dates.filter(d => habit.checks[d]).length;
      return e('div', { className:'flex flex-col' },
        e('div', { className:'flex items-center justify-between min-h-[14px] mt-2' },
          e('div', { className:'flex items-center gap-2 flex-1 min-w-0' },
            e('div', { className:'text-[11px] font-black text-slate-700 truncate' }, habit.name),
            e('button', { type:'button', onMouseDown:ev=>ev.preventDefault(), onClick:(ev)=>{ ev.preventDefault();ev.stopPropagation();onAction(habit.id,'EDIT_NAME'); }, className:'text-[8px] text-indigo-300 font-bold flex-shrink-0' }, '수정'),
            e('button', { type:'button', onMouseDown:ev=>ev.preventDefault(), onClick:(ev)=>{ ev.preventDefault();ev.stopPropagation();onAction(habit.id,'DELETE'); }, className:'text-[8px] text-pink-300 font-bold flex-shrink-0' }, '지우기')
          ),
          e('div', { className:'text-[9px] font-black text-slate-800 flex-shrink-0' }, `${rangeCount}회 / ${habit.total||0}`)
        ),
        e('div', { className:'scroll-container no-scrollbar' },
          [...dates].reverse().map(d =>
            e('button', { key:d, type:'button', onMouseDown:ev=>ev.preventDefault(), onTouchStart:ev=>ev.stopPropagation(), onClick:(ev)=>{ ev.preventDefault();ev.stopPropagation();onAction(habit.id,d); }, className:`w-7 h-7 rounded-lg flex-shrink-0 chk-btn ${habit.checks[d]?'active':'bg-slate-100'}` },
              habit.checks[d] && e('span', { className:'text-white text-[10px] font-bold' }, '✓'))
          )
        )
      );
    });

    /* ──────────────────────────────────────────────────────
       [PERF FIX] NoteBox: 각 노트 아이템을 별도 memo 컴포넌트로 분리
       → 한 노트 편집 시 다른 노트 및 상위 컴포넌트 리렌더 방지
    ────────────────────────────────────────────────────── */
    const NoteItem = memo(({ note, onToggle, onDelete, onEdit, nextInputRef }) => {
      // uncontrolled input: defaultValue + onBlur로 상위 상태 업데이트
      const inputRef = useRef(null);
      return e('div', { className:`notebox-item${note.done?' done':''}` },
        e('button', { type:'button', onMouseDown:ev=>ev.preventDefault(), onClick:()=>onToggle(note.id), className:`w-4 h-4 rounded border-2 flex-shrink-0 flex items-center justify-center ${note.done?'bg-indigo-500 border-indigo-500':'border-slate-300'}` },
          note.done && e('span', { className:'text-white text-[8px]' }, '✓')
        ),
        e('input', {
          ref: inputRef,
          type: 'text',
          defaultValue: note.text,
          onBlur: (ev) => { if (ev.target.value !== note.text) onEdit(note.id, ev.target.value); },
          onKeyDown: (ev) => { if(ev.key==='Enter' && nextInputRef) nextInputRef.current?.focus(); },
          className: 'flex-1 bg-transparent border-none outline-none text-sm font-semibold',
          style: { textDecoration: note.done?'line-through':'none', color: note.done?'#94a3b8':'#334155' }
        }),
        e('button', { type:'button', onClick:()=>onDelete(note.id), className:'text-slate-200 text-xs px-1 flex-shrink-0' }, '✕')
      );
    });

    /* [PERF FIX] NoteBox: 추가 input을 완전히 uncontrolled로 처리 */
    const NoteBox = memo(({ notes, setNotes }) => {
      const addInputRef = useRef(null);
      const [hasText, setHasText] = useState(false);

      const addNote = useCallback(() => {
        const t = (addInputRef.current?.value || '').trim();
        if (!t) return;
        setNotes(p => [...p, { id: Date.now(), text: t, done: false }]);
        if (addInputRef.current) addInputRef.current.value = '';
        setHasText(false);
      }, [setNotes]);

      const toggleDone = useCallback((id) => setNotes(p => p.map(n => n.id===id ? {...n, done:!n.done} : n)), [setNotes]);
      const deleteNote = useCallback((id) => setNotes(p => p.filter(n => n.id!==id)), [setNotes]);
      const editNote = useCallback((id, text) => setNotes(p => p.map(n => n.id===id ? {...n, text} : n)), [setNotes]);

      const handleAddKeyDown = useCallback((ev) => { if(ev.key==='Enter') addNote(); }, [addNote]);
      const handleAddInput = useCallback((ev) => { setHasText(ev.target.value.trim().length > 0); }, []);

      return e('div', { className:'mb-8' },
        e('div', { className:'flex justify-between items-center mb-3 px-2' },
          e('h3', { className:'text-[11px] font-black text-slate-400 uppercase tracking-widest' }, '✏️ 생각 노트'),
        ),
        e('div', { className:'notebox' },
          notes.map(n =>
            e(NoteItem, { key: n.id, note: n, onToggle: toggleDone, onDelete: deleteNote, onEdit: editNote, nextInputRef: addInputRef })
          ),
          e('div', { className:'notebox-add' },
            e('div', { className:'w-4 h-4 rounded border-2 border-dashed border-slate-200 flex-shrink-0' }),
            e('input', {
              ref: addInputRef,
              type: 'text',
              placeholder: '새 메모 추가...',
              onInput: handleAddInput,
              onKeyDown: handleAddKeyDown,
              className: 'flex-1 bg-transparent border-none outline-none text-sm text-slate-500'
            }),
            hasText && e('button', { type:'button', onClick:addNote, className:'text-indigo-500 font-black text-sm px-1' }, '+')
          )
        )
      );
    });

    /* ──────────────────────────────────────────────────────
       [PERF FIX] GoalInputField: 목표 입력 필드를 uncontrolled로 분리
       → 타이핑 중 App 리렌더 완전 차단
    ────────────────────────────────────────────────────── */
    const GoalInputField = memo(({ value, disabled, placeholder, onChange, isTextarea, className }) => {
      const ref = useRef(null);
      // disabled 해제 시 ref 값 동기화
      useEffect(() => { if (ref.current && ref.current.value !== value) ref.current.value = value; }, [value, disabled]);
      const handleBlur = useCallback((ev) => { if (ev.target.value !== value) onChange(ev.target.value); }, [value, onChange]);
      if (disabled) {
        return e(isTextarea ? 'textarea' : 'input', { className, disabled: true, value, readOnly: true });
      }
      return e(isTextarea ? 'textarea' : 'input', {
        ref,
        className,
        defaultValue: value,
        placeholder,
        onBlur: handleBlur,
      });
    });

    /* ──────────────────────────────────────────────────────
       [PERF FIX] BottomBar: 하단 입력바를 완전히 분리된 컴포넌트로
       → inputVal 타이핑이 App 전체 리렌더를 유발하지 않음
    ────────────────────────────────────────────────────── */
    const BottomBar = memo(({ themes, curTheme, onThemeChange, onAdd, onOpenModal }) => {
      const textareaRef = useRef(null);

      const handleAdd = useCallback(() => {
        const val = (textareaRef.current?.value || '').trim();
        if (!val) return;
        onAdd(val);
        if (textareaRef.current) textareaRef.current.value = '';
      }, [onAdd]);

      const handleKeyDown = useCallback((ev) => {
        if (ev.key === 'Enter' && !ev.shiftKey) { ev.preventDefault(); handleAdd(); }
      }, [handleAdd]);

      const handleThemeChange = useCallback((ev) => {
        if (ev.target.value === 'ADD_NEW_THEME_ACTION') {
          onOpenModal('THEME_ADD', null, '');
        } else {
          onThemeChange(ev.target.value);
        }
      }, [onThemeChange, onOpenModal]);

      return e('div', { className:'fixed bottom-6 left-0 right-0 px-5 max-w-md mx-auto z-[8000]' },
        e('div', { className:'bg-slate-900 p-2 rounded-[2rem] shadow-2xl flex items-center gap-2' },
          e('select', { className:'theme-select-fixed text-[11px] font-black bg-slate-800 text-white px-2 py-3 rounded-2xl outline-none', value:curTheme, onChange:handleThemeChange },
            e('option',{value:'',disabled:true},'테마 선택'),
            themes.map(t=>e('option',{key:t,value:t},t)),
            e('option',{value:'칠판'},'★ 칠판'),
            e('option',{value:'ADD_NEW_THEME_ACTION',className:'text-indigo-400 font-bold'},'+ 테마 추가')
          ),
          e('textarea', {
            ref: textareaRef,
            className: 'flex-1 bg-transparent p-2 text-sm text-white outline-none resize-none pt-2 overflow-hidden',
            rows: 2,
            placeholder: '추가할 내용...',
            onKeyDown: handleKeyDown,
          }),
          e('button', { type:'button', onClick:handleAdd, className:'bg-indigo-500 text-white w-12 h-12 rounded-[1.2rem] font-black flex-shrink-0' }, '+')
        )
      );
    });

    /* ──────────────────────────────────────────────────────
       [PERF FIX] BoardInputBar: 칠판 모드 입력도 분리
    ────────────────────────────────────────────────────── */
    const BoardInputBar = memo(({ onAdd }) => {
      const textareaRef = useRef(null);
      const handleAdd = useCallback(() => {
        const val = (textareaRef.current?.value || '').trim();
        if (!val) return;
        onAdd(val);
        if (textareaRef.current) textareaRef.current.value = '';
      }, [onAdd]);
      return e('div', { className:'flex-1 flex items-center bg-slate-50 rounded-xl px-3 py-1 ml-2' },
        e('textarea', { ref: textareaRef, className:'flex-1 bg-transparent text-sm outline-none font-bold text-slate-700 resize-none pt-1 overflow-hidden', rows:1, placeholder:'메모 입력...' }),
        e('button', { type:'button', onClick:handleAdd, className:'text-indigo-600 font-black px-2' }, '+')
      );
    });

    /* ──────────────────────────────────────────────────────
       [PERF FIX] DayRangeInputs: 과거/미래 입력 분리
    ────────────────────────────────────────────────────── */
    const DayRangeInputs = memo(({ pastDays, futureDays, onPastChange, onFutureChange }) => {
      return e('div', { className:'flex flex-col gap-1 items-end' },
        e('div', { className:'bg-white px-3 py-1.5 rounded-xl shadow-sm border border-slate-50 flex items-center gap-2' },
          e('span', { className:'text-[9px] font-black text-slate-400 uppercase' }, '과거'),
          e('input', {
            type: 'number',
            className: 'w-8 text-center font-bold text-indigo-600 outline-none text-sm',
            defaultValue: pastDays,
            onBlur: (ev) => onPastChange(Math.max(1, parseInt(ev.target.value)||1)),
            onChange: (ev) => onPastChange(Math.max(1, parseInt(ev.target.value)||1))
          })
        ),
        e('div', { className:'bg-white px-3 py-1.5 rounded-xl shadow-sm border border-slate-50 flex items-center gap-2' },
          e('span', { className:'text-[9px] font-black text-slate-400 uppercase' }, '미래'),
          e('input', {
            type: 'number',
            className: 'w-8 text-center font-bold text-emerald-600 outline-none text-sm',
            defaultValue: futureDays,
            onBlur: (ev) => onFutureChange(Math.max(0, parseInt(ev.target.value)||0)),
            onChange: (ev) => onFutureChange(Math.max(0, parseInt(ev.target.value)||0))
          })
        )
      );
    });

    const App = () => {
      const [habits, setHabits] = useState(() => getInitialData('habits_final', []));
      const [themes, setThemes] = useState(() => getInitialData('themes_final', []));
      const [categories, setCategories] = useState(() => getInitialData('categories_v91', []));
      const [pastDays, setPastDays] = useState(() => getInitialData('past_days_v1', 14));
      const [futureDays, setFutureDays] = useState(() => getInitialData('future_days_v1', 0));
      const [hiddenThemes, setHiddenThemes] = useState(() => getInitialData('hidden_themes', {}));
      const [hiddenCategories, setHiddenCategories] = useState(() => getInitialData('hidden_categories_v1', {}));
      const [hiddenFolderOpen, setHiddenFolderOpen] = useState(false);
      const [hiddenCatFolderOpen, setHiddenCatFolderOpen] = useState(false);
      const [todayStr, setTodayStr] = useState(getTodayStr());
      const [goals, setGoals] = useState(() => getInitialData('goals_array_v1', [{ id: Date.now(), project:'', targetItems:[], reason:'', startDate:'', endDate:'', isEditing:false }]));
      const [collapsedStates, setCollapsedStates] = useState(() => {
        const saved = getInitialData('collapsed_states_v1', null);
        if (saved) return saved;
        const s = {};
        const ci = (list) => { list.forEach(c => { s[c.id]=true; ci(c.subCategories||[]); }); };
        getInitialData('goals_array_v1',[]).forEach(g => { s[g.id]=true; });
        ci(getInitialData('categories_v91',[]));
        getInitialData('themes_final',[]).forEach(t => { s[t]=true; });
        return s;
      });
      const [memos, setMemos] = useState(() => getInitialData('memos_final', []));
      const [notes, setNotes] = useState(() => getInitialData('notes_v1', []));
      const [selectedMemoId, setSelectedMemoId] = useState(null);
      const [boardMode, setBoardMode] = useState('cursor');
      const [penColor, setPenColor] = useState('#ef4444');
      const [penSize, setPenSize] = useState(5);
      const [eraserSize, setEraserSize] = useState(20);
      const [boardFullscreen, setBoardFullscreen] = useState(false);
      const [boardCollapsed, setBoardCollapsed] = useState(() => getInitialData('board_collapsed_v1', true));
      const [boardTransform, setBoardTransform] = useState(() => getInitialData('board_transform_final', { x:0, y:0, s:10 }));
      const [curTheme, setCurTheme] = useState('');
      const [modalState, setModalState] = useState({ type:null, targetId:null, parentCategoryId:null });
      const [analysisSelectedThemes, setAnalysisSelectedThemes] = useState(() => getInitialData('analysis_selected_themes_v1', null));
      const [analysisSelectedCats, setAnalysisSelectedCats] = useState(() => getInitialData('analysis_selected_cats_v1', null));
      const [priorityThemes, setPriorityThemes] = useState(() => new Set(getInitialData('priority_themes_v1', [])));
      const [analysisPage, setAnalysisPage] = useState(0);

      const boardAreaRef = useRef(null); const boardContentRef = useRef(null); const canvasRef = useRef(null);
      const lastPinchDist = useRef(null); const lastTouchPos = useRef({x:0,y:0});
      const memoDragIdRef = useRef(null); const memoResizeIdRef = useRef(null); const resizeDirRef = useRef(null);
      const memoOffsetRef = useRef({x:0,y:0}); const isPanningRef = useRef(false); const isDrawingRef = useRef(false);
      const domMemoRefs = useRef(new Map()); const memoPosTemp = useRef(new Map()); const memoDimTemp = useRef(new Map());
      const pendingBoardTransform = useRef({...boardTransform}); const rafPending = useRef(null);
      const offscreenCanvasRef = useRef(null); const drawFlushRef = useRef(null);
      const swipeStartX = useRef(null); const swipeStartTime = useRef(null); const swipeDeltaX = useRef(0);
      const analysisPanelInnerRef = useRef(null);

      useEffect(() => { const t=setInterval(()=>{ const n=getTodayStr(); if(n!==todayStr) setTodayStr(n); },60000); return ()=>clearInterval(t); }, [todayStr]);

      const saveTimer = useRef(null);
      useEffect(() => {
        if (saveTimer.current) clearTimeout(saveTimer.current);
        saveTimer.current = setTimeout(() => {
          try {
            localStorage.setItem('habits_final', JSON.stringify(habits));
            localStorage.setItem('themes_final', JSON.stringify(themes));
            localStorage.setItem('categories_v91', JSON.stringify(categories));
            localStorage.setItem('memos_final', JSON.stringify(memos));
            localStorage.setItem('notes_v1', JSON.stringify(notes));
            localStorage.setItem('past_days_v1', JSON.stringify(pastDays));
            localStorage.setItem('future_days_v1', JSON.stringify(futureDays));
            localStorage.setItem('goals_array_v1', JSON.stringify(goals));
            localStorage.setItem('board_transform_final', JSON.stringify(boardTransform));
            localStorage.setItem('hidden_themes', JSON.stringify(hiddenThemes));
            localStorage.setItem('hidden_categories_v1', JSON.stringify(hiddenCategories));
            localStorage.setItem('board_collapsed_v1', JSON.stringify(boardCollapsed));
            localStorage.setItem('collapsed_states_v1', JSON.stringify(collapsedStates));
            localStorage.setItem('priority_themes_v1', JSON.stringify([...priorityThemes]));
            if (analysisSelectedThemes!==null) localStorage.setItem('analysis_selected_themes_v1', JSON.stringify(analysisSelectedThemes));
            if (analysisSelectedCats!==null) localStorage.setItem('analysis_selected_cats_v1', JSON.stringify(analysisSelectedCats));
          } catch(err) { console.warn('save error',err); }
        }, 700);
        return () => clearTimeout(saveTimer.current);
      }, [habits, themes, categories, memos, notes, pastDays, futureDays, goals, boardTransform, hiddenThemes, hiddenCategories, boardCollapsed, collapsedStates, analysisSelectedThemes, analysisSelectedCats, priorityThemes]);

      useEffect(() => {
        offscreenCanvasRef.current = document.createElement('canvas');
        offscreenCanvasRef.current.width = 5000; offscreenCanvasRef.current.height = 5000;
        const canvas = canvasRef.current;
        if (canvas && canvas.getContext) { const ctx=canvas.getContext('2d'); const si=localStorage.getItem('board_drawing_v3'); if(si){ const img=new Image(); img.src=si; img.onload=()=>{ ctx.drawImage(img,0,0); if(offscreenCanvasRef.current) offscreenCanvasRef.current.getContext('2d').drawImage(img,0,0); }; } }
      }, []);

      const dates = useMemo(() => {
        const arr=[];
        for(let i=-(pastDays-1);i<=futureDays;i++){ const d=new Date(todayStr); d.setDate(d.getDate()+i); arr.push(`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`); }
        return arr;
      }, [pastDays, futureDays, todayStr]);

      const themeAnalysis = useMemo(() => themes.map(t => { const th=habits.filter(h=>h.theme===t); if(!th.length) return {name:t,score:0}; const tc=th.reduce((a,h)=>a+dates.filter(d=>h.checks[d]).length,0); return {name:t,score:Math.round((tc/(th.length*dates.length))*100)}; }), [themes, habits, dates]);

      const visibleThemesForAnalysis = useMemo(() => {
        const nh = themes.filter(t => !hiddenThemes[t]);
        if (!analysisSelectedThemes) return nh;
        return nh.filter(t => analysisSelectedThemes.includes(t));
      }, [themes, hiddenThemes, analysisSelectedThemes]);

      const getCategoryThemes = useCallback((cat) => {
        const collect = (c) => { const all=[...(c.themes||[])]; (c.subCategories||[]).forEach(sub=>collect(sub).forEach(t=>all.push(t))); return [...new Set(all)]; };
        return collect(cat);
      }, []);

      const cleanCategoryThemes = useCallback((currentThemes, cats) => {
        const tSet = new Set(currentThemes);
        const clean = (list) => list.map(c => ({ ...c, themes: (c.themes||[]).filter(t=>tSet.has(t)), subCategories: clean(c.subCategories||[]) }));
        return clean(cats);
      }, []);

      useEffect(() => {
        setCategories(prev => cleanCategoryThemes(themes, prev));
      }, [themes, cleanCategoryThemes]);

      const getCategoryDailyScores = useCallback((cat) => {
        const catThemes = getCategoryThemes(cat);
        return dates.map(d => { if(!catThemes.length) return 0; return catThemes.reduce((acc,tName)=>{ const th=habits.filter(h=>h.theme===tName); if(!th.length) return acc; return acc+Math.round((th.filter(h=>h.checks[d]).length/th.length)*100); },0); });
      }, [dates, habits, getCategoryThemes]);

      const allCatsFlat = useMemo(() => {
        const result = [];
        const collect = (list) => list.forEach(c => { result.push(c); collect(c.subCategories||[]); });
        collect(categories);
        return result;
      }, [categories]);

      const visibleCatsForAnalysis = useMemo(() => {
        const nonHidden = allCatsFlat.filter(c => !hiddenCategories[c.id] && getCategoryThemes(c).length > 0);
        if (!analysisSelectedCats) return nonHidden;
        return nonHidden.filter(c => analysisSelectedCats.includes(c.id));
      }, [allCatsFlat, hiddenCategories, analysisSelectedCats, getCategoryThemes]);

      const updateCategoryRecursive = (list, targetId, updateFn) => list.map(cat => {
        if (cat.id===targetId) return updateFn(cat);
        if (cat.subCategories) return {...cat, subCategories:updateCategoryRecursive(cat.subCategories,targetId,updateFn)};
        return cat;
      });

      const extractCategory = (list, targetId) => {
        let extracted = null;
        const remove = (arr) => { const res=[]; for(const cat of arr){ if(cat.id===targetId){ extracted=cat; }else{ res.push({...cat,subCategories:remove(cat.subCategories||[])}); } } return res; };
        return { newList: remove(list), extracted };
      };

      const removeThemeFromAllCategories = (list, tName) => list.map(cat => ({ ...cat, themes:(cat.themes||[]).filter(t=>t!==tName), subCategories:removeThemeFromAllCategories(cat.subCategories||[],tName) }));

      const getGoalDates = (startDate, endDate) => {
        const s=new Date(startDate),en=new Date(endDate); if(isNaN(s)||isNaN(en)||s>en) return [];
        let c=new Date(s);const arr=[];
        while(c<=en){ arr.push(`${c.getFullYear()}-${String(c.getMonth()+1).padStart(2,'0')}-${String(c.getDate()).padStart(2,'0')}`); c.setDate(c.getDate()+1); }
        return arr;
      };

      const calculateGoalProgress = (goalObj) => {
        const gDates=getGoalDates(goalObj.startDate,goalObj.endDate);
        if(!goalObj.targetItems.length||!gDates.length) return 0;
        let cur=0,tar=0;
        goalObj.targetItems.forEach(item => {
          if(item.type==='category'){ const ct=item.catThemes||[]; if(!ct.length) return; const ms=ct.length*100; const ach=ct.reduce((a,tN)=>{ const th=habits.filter(h=>h.theme===tN); if(!th.length) return a; return a+gDates.reduce((da,d)=>da+Math.round((th.filter(h=>h.checks[d]).length/th.length)*100),0); },0); cur+=(ach/gDates.length/ms)*100; tar+=item.target; }
          else { const th=habits.filter(h=>h.theme===item.theme); if(!th.length) return; const c=th.reduce((a,h)=>a+gDates.filter(d=>h.checks[d]).length,0); cur+=(c/(th.length*gDates.length))*100; tar+=item.target; }
        });
        return tar>0?(cur/tar)*100:0;
      };

      const getDayDiffText = (s, t) => { if(!s||!t) return ''; const d1=new Date(s),d2=new Date(t); if(isNaN(d1)||isNaN(d2)) return ''; const dd=Math.ceil((d2-d1)/(1000*60*60*24))+1; return dd>0?`${dd}일차`:''; };

      const flatCategoryList = useMemo(() => { const res=[]; const col=(list,d)=>list.forEach(c=>{ res.push({id:c.id,name:'　'.repeat(d)+c.name,catThemes:getCategoryThemes(c)}); col(c.subCategories||[],d+1); }); col(categories,0); return res; }, [categories, getCategoryThemes]);

      const addNewGoal = useCallback(() => setGoals(p=>[...p,{id:Date.now(),project:'',targetItems:[],reason:'',startDate:'',endDate:'',isEditing:true}]), []);
      const updateGoal = useCallback((id,fields) => setGoals(p=>p.map(g=>g.id===id?{...g,...fields}:g)), []);
      const deleteGoal = useCallback((id) => { if(confirm('삭제할까요?')) setGoals(p=>p.filter(g=>g.id!==id)); }, []);
      const toggleGoalEditing = useCallback((id) => setGoals(p=>p.map(g=>g.id===id?{...g,isEditing:!g.isEditing}:g)), []);
      const toggleThemeHide = useCallback((tName) => setHiddenThemes(prev=>({...prev,[tName]:!prev[tName]})), []);
      const toggleCategoryHide = useCallback((catId) => setHiddenCategories(prev=>({...prev,[catId]:!prev[catId]})), []);
      const toggleCollapse = useCallback((id) => setCollapsedStates(p=>({...p,[id]:!p[id]})), []);

      const toggleCollapseCategory = useCallback((catId, catObj) => {
        setCollapsedStates(p => {
          const wasCollapsed = p[catId];
          if (wasCollapsed) {
            const newState = { ...p, [catId]: false };
            const collapseCharts = (c) => {
              newState['cat_chart_' + c.id] = true;
              (c.themes || []).forEach(tName => { newState[tName] = true; });
              (c.subCategories || []).forEach(sub => collapseCharts(sub));
            };
            if (catObj) collapseCharts(catObj);
            return newState;
          }
          return { ...p, [catId]: true };
        });
      }, []);

      const togglePriority = useCallback((tName) => {
        setPriorityThemes(prev => { const next=new Set(prev); if(next.has(tName)) next.delete(tName); else next.add(tName); return next; });
        setThemes(prev => { const without=prev.filter(t=>t!==tName); const np=new Set(priorityThemes); if(np.has(tName)){ np.delete(tName); return [...without,tName]; } else { np.add(tName); return [tName,...without]; } });
      }, [priorityThemes]);

      const getCanvasPos = useCallback((ev) => { const rect=boardAreaRef.current.getBoundingClientRect(); const cx=ev.clientX!==undefined?ev.clientX:ev.touches[0].clientX; const cy=ev.clientY!==undefined?ev.clientY:ev.touches[0].clientY; return {x:(cx-rect.left-pendingBoardTransform.current.x)/pendingBoardTransform.current.s,y:(cy-rect.top-pendingBoardTransform.current.y)/pendingBoardTransform.current.s}; }, []);

      /* [PERF FIX] handleAdd: BottomBar에서 이미 가공된 val 문자열을 받음 */
      const handleAdd = useCallback((val) => {
        if (!val) return;
        if(curTheme==='칠판'||(boardFullscreen&&!boardCollapsed)){ const aw=boardAreaRef.current.clientWidth,ah=boardAreaRef.current.clientHeight; const sx=(aw/2-pendingBoardTransform.current.x)/pendingBoardTransform.current.s-75,sy=(ah/2-pendingBoardTransform.current.y)/pendingBoardTransform.current.s-40; setMemos(p=>[...p,{id:Date.now(),text:val,x:sx,y:sy,w:150,h:80,locked:false}]); }
        else if(curTheme&&themes.includes(curTheme)){ setHabits(p=>[...p,{id:Date.now(),name:val,theme:curTheme,checks:{},total:0}]); }
        else if(!themes.includes(val)){ setThemes(p=>[...p,val]); setCurTheme(val); }
      }, [curTheme, themes, boardFullscreen, boardCollapsed]);

      const commitMemoTempToState = useCallback(() => {
        if(memoPosTemp.current.size===0&&memoDimTemp.current.size===0) return;
        setMemos(prev=>prev.map(m=>{ const pos=memoPosTemp.current.get(m.id); const dim=memoDimTemp.current.get(m.id); return {...m,x:pos?pos.x:m.x,y:pos?pos.y:m.y,w:dim?dim.w:m.w,h:dim?dim.h:m.h}; }));
        memoPosTemp.current.clear(); memoDimTemp.current.clear();
      }, []);

      const handlePointerMove = useCallback((ev) => {
        if(memoDragIdRef.current!==null){ ev.preventDefault(); const id=memoDragIdRef.current; const rect=boardAreaRef.current.getBoundingClientRect(); const px=(ev.clientX-rect.left-pendingBoardTransform.current.x)/pendingBoardTransform.current.s-memoOffsetRef.current.x; const py=(ev.clientY-rect.top-pendingBoardTransform.current.y)/pendingBoardTransform.current.s-memoOffsetRef.current.y; memoPosTemp.current.set(id,{x:px,y:py}); const el=domMemoRefs.current.get(id); if(el){el.style.left=`${px}px`;el.style.top=`${py}px`;} return; }
        if(memoResizeIdRef.current!==null){ ev.preventDefault(); const id=memoResizeIdRef.current; const rect=boardAreaRef.current.getBoundingClientRect(); const px=(ev.clientX-rect.left-pendingBoardTransform.current.x)/pendingBoardTransform.current.s; const py=(ev.clientY-rect.top-pendingBoardTransform.current.y)/pendingBoardTransform.current.s; const m=memos.find(mm=>mm.id===id); if(!m) return; if(resizeDirRef.current==='h'){const nw=Math.max(50,px-m.x);memoDimTemp.current.set(id,{w:nw,h:m.h});const el=domMemoRefs.current.get(id);if(el)el.style.width=`${nw}px`;}else if(resizeDirRef.current==='v'){const nh=Math.max(30,py-m.y);memoDimTemp.current.set(id,{w:m.w,h:nh});const el=domMemoRefs.current.get(id);if(el)el.style.height=`${nh}px`;} return; }
      }, [memos]);
      const handlePointerUp = useCallback(() => { memoDragIdRef.current=null;memoResizeIdRef.current=null;resizeDirRef.current=null;commitMemoTempToState(); }, [commitMemoTempToState]);
      const applyPendingTransformToDOM = useCallback(() => { if(!boardContentRef.current) return; boardContentRef.current.style.transform=`translate(${pendingBoardTransform.current.x}px,${pendingBoardTransform.current.y}px) scale(${pendingBoardTransform.current.s})`; }, []);
      const handleBoardPointerDown = useCallback((ev) => { if(boardMode!=='cursor'||memoDragIdRef.current!==null||memoResizeIdRef.current!==null) return; isPanningRef.current=true; lastTouchPos.current={x:ev.clientX,y:ev.clientY}; }, [boardMode]);
      const handleBoardPointerMove = useCallback((ev) => { if(!isPanningRef.current||boardMode!=='cursor') return; const dx=ev.clientX-lastTouchPos.current.x,dy=ev.clientY-lastTouchPos.current.y; pendingBoardTransform.current.x+=dx;pendingBoardTransform.current.y+=dy; lastTouchPos.current={x:ev.clientX,y:ev.clientY}; if(!rafPending.current){rafPending.current=requestAnimationFrame(()=>{applyPendingTransformToDOM();rafPending.current=null;});} }, [boardMode, applyPendingTransformToDOM]);
      const handleBoardPointerUp = useCallback(() => { isPanningRef.current=false; setBoardTransform({...pendingBoardTransform.current}); }, []);
      const handleBoardTouch = useCallback((ev) => { if(boardMode!=='cursor'||memoDragIdRef.current!==null||memoResizeIdRef.current!==null) return; if(ev.touches.length===2){ const t1=ev.touches[0],t2=ev.touches[1]; const dist=Math.hypot(t1.pageX-t2.pageX,t1.pageY-t2.pageY); const mx=(t1.clientX+t2.clientX)/2,my=(t1.clientY+t2.clientY)/2; const rect=boardAreaRef.current.getBoundingClientRect(); const lmx=mx-rect.left,lmy=my-rect.top; if(lastPinchDist.current!==null){ const delta=dist/lastPinchDist.current; const ns=Math.min(Math.max(pendingBoardTransform.current.s*delta,0.1),10); const Px=(lmx-pendingBoardTransform.current.x)/pendingBoardTransform.current.s; const Py=(lmy-pendingBoardTransform.current.y)/pendingBoardTransform.current.s; pendingBoardTransform.current={x:lmx-Px*ns,y:lmy-Py*ns,s:ns}; if(!rafPending.current){rafPending.current=requestAnimationFrame(()=>{applyPendingTransformToDOM();rafPending.current=null;});} } lastPinchDist.current=dist; } }, [boardMode, applyPendingTransformToDOM]);
      const handleMemoDown = useCallback((ev, memo) => { ev.stopPropagation(); setSelectedMemoId(memo.id); if(boardMode!=='cursor'||memo.locked) return; const rect=ev.currentTarget.getBoundingClientRect(); memoOffsetRef.current={x:(ev.clientX-rect.left)/pendingBoardTransform.current.s,y:(ev.clientY-rect.top)/pendingBoardTransform.current.s}; memoDragIdRef.current=memo.id; }, [boardMode]);
      const flushDraw = useCallback(() => { drawFlushRef.current=null; if(!canvasRef.current||!offscreenCanvasRef.current) return; const ctx=canvasRef.current.getContext('2d'); ctx.clearRect(0,0,5000,5000); ctx.drawImage(offscreenCanvasRef.current,0,0); }, []);
      const startDrawing = useCallback((ev) => { if(boardMode==='cursor') return; ev.preventDefault(); const oc=offscreenCanvasRef.current.getContext('2d'); const pos=getCanvasPos(ev); oc.beginPath();oc.moveTo(pos.x,pos.y);oc.lineCap='round';oc.lineJoin='round'; if(boardMode==='eraser'){oc.globalCompositeOperation='destination-out';oc.lineWidth=eraserSize;}else{oc.globalCompositeOperation='source-over';oc.strokeStyle=penColor;oc.lineWidth=penSize;} isDrawingRef.current=true; }, [boardMode, eraserSize, penColor, penSize, getCanvasPos]);
      const draw = useCallback((ev) => { if(!isDrawingRef.current) return; ev.preventDefault(); const oc=offscreenCanvasRef.current.getContext('2d'); const pos=getCanvasPos(ev); oc.lineTo(pos.x,pos.y);oc.stroke();oc.beginPath();oc.moveTo(pos.x,pos.y); if(!drawFlushRef.current){drawFlushRef.current=requestAnimationFrame(flushDraw);} }, [getCanvasPos, flushDraw]);
      const stopDrawing = useCallback(() => { if(isDrawingRef.current){ isDrawingRef.current=false; if(drawFlushRef.current){cancelAnimationFrame(drawFlushRef.current);drawFlushRef.current=null;} flushDraw(); try{localStorage.setItem('board_drawing_v3',canvasRef.current.toDataURL());}catch(err){console.warn(err);} } }, [flushDraw]);

      const openModal = useCallback((type, targetId, val, parentId=null) => {
        setModalState({type,targetId,parentCategoryId:parentId});
        const te=document.getElementById('modal-title');
        if(type==='ADD_ROOT_CATEGORY') te.innerText='최상위 카테고리 추가';
        else if(type==='ADD_SUB_CATEGORY') te.innerText='하위 카테고리 추가';
        else if(type==='CATEGORY_RENAME') te.innerText='카테고리 이름 수정';
        else if(type==='THEME_ADD') te.innerText='새 테마 추가';
        else if(type.includes('THEME')) te.innerText='테마 수정';
        else te.innerText='수정';
        document.getElementById('common-input').value=val||'';
        document.getElementById('external-modal').classList.add('active');
      }, []);

      const handleModalSubmit = useCallback(() => {
        const val=document.getElementById('common-input').value.trim(); if(!val) return;
        const {type,targetId,parentCategoryId}=modalState;
        if(type==='ADD_ROOT_CATEGORY') setCategories(p=>[...p,{id:Date.now(),name:val,subCategories:[],themes:[]}]);
        else if(type==='ADD_SUB_CATEGORY') setCategories(p=>updateCategoryRecursive(p,parentCategoryId,c=>({...c,subCategories:[...c.subCategories,{id:Date.now(),name:val,subCategories:[],themes:[]}]})));
        else if(type==='CATEGORY_RENAME') setCategories(p=>updateCategoryRecursive(p,targetId,c=>({...c,name:val})));
        else if(type==='THEME_EDIT'){setThemes(p=>p.map(t=>t===targetId?val:t));setHabits(p=>p.map(h=>h.theme===targetId?{...h,theme:val}:h));if(curTheme===targetId)setCurTheme(val);}
        else if(type==='HABIT_EDIT') setHabits(p=>p.map(h=>h.id===targetId?{...h,name:val}:h));
        else if(type==='MEMO_EDIT') setMemos(p=>p.map(m=>m.id===targetId?{...m,text:val}:m));
        else if(type==='THEME_ADD'){setThemes(p=>[...p,val]);setCurTheme(val);}
        window.closeModal();
      }, [modalState, curTheme]);

      useEffect(() => { document.getElementById('modal-submit-btn').onclick=handleModalSubmit; }, [handleModalSubmit]);

      const handleHabitAction = useCallback((hid, act) => {
        if(act==='DELETE'){if(confirm('삭제할까요?'))setHabits(h=>h.filter(x=>x.id!==hid));}
        else if(act==='EDIT_NAME'){const h=habits.find(x=>x.id===hid);openModal('HABIT_EDIT',hid,h?h.name:'');}
        else{setHabits(prev=>prev.map(x=>x.id===hid?{...x,checks:{...x.checks,[act]:!x.checks[act]},total:x.total+(x.checks[act]?-1:1)}:x));}
      }, [habits, openModal]);

      const allCategoryThemes = useMemo(() => { const col=(list)=>list.flatMap(c=>[...(c.themes||[]),...col(c.subCategories||[])]); return new Set(col(categories)); }, [categories]);

      const sortedThemesInCategory = useCallback((tList) => [...tList].sort((a,b)=>{ const pa=priorityThemes.has(a)?0:1,pb=priorityThemes.has(b)?0:1; return pa-pb; }), [priorityThemes]);

      const renderTheme = useCallback((tName) => {
        if(hiddenThemes[tName]) return null;
        const isPriority = priorityThemes.has(tName);
        const tHabits = habits.filter(h=>h.theme===tName);
        const dailyScores = dates.map(d=>tHabits.length?Math.round((tHabits.filter(h=>h.checks[d]).length/tHabits.length)*100):0);
        const isCollapsed = collapsedStates[tName];
        let activeTarget=0,gDates=[];
        goals.forEach(g=>{const item=g.targetItems.find(it=>it.theme===tName&&it.type!=='category');if(item&&item.target>activeTarget){activeTarget=item.target;gDates=getGoalDates(g.startDate,g.endDate);}});
        const periodScore=(()=>{if(!gDates.length||!tHabits.length)return 0;const tc=tHabits.reduce((a,h)=>a+gDates.filter(d=>h.checks[d]).length,0);return Math.round((tc/(tHabits.length*gDates.length))*100);})();
        return e('div', { key:tName, className:`theme-card bg-white rounded-[2rem] card-elevated border border-slate-200 mb-3 overflow-hidden${isPriority?' priority':''}` },
          e('div', { className:'flex justify-between items-center p-5 cursor-pointer', onClick:()=>toggleCollapse(tName) },
            e('div', { className:'flex items-center gap-2 flex-wrap' },
              isPriority && e('span', { className:'text-amber-400 text-sm' }, '⭐'),
              e('h2', { className:`text-lg font-black ${isPriority?'text-amber-700':'text-slate-800'}` }, tName),
              e('button', { type:'button', onClick:(ev)=>{ev.stopPropagation();openModal('THEME_EDIT',tName,tName);}, className:'text-indigo-400 text-[9px] font-bold px-1.5 py-0.5 bg-indigo-50 rounded-md' }, '수정'),
              e('button', { type:'button', onClick:(ev)=>{ev.stopPropagation();togglePriority(tName);}, className:`text-[9px] font-bold px-1.5 py-0.5 rounded-md ${isPriority?'bg-amber-100 text-amber-600':'bg-slate-100 text-slate-400'}` }, isPriority?'⭐우선':'☆순위'),
              e('span', { className:'text-[10px] font-black text-indigo-400' }, isCollapsed?'▼':'▲'),
              e('button', { type:'button', onClick:(ev)=>{ev.stopPropagation();toggleThemeHide(tName);}, className:'text-slate-400 text-[10px] ml-1' }, e('i', { className:'fa-solid fa-eye-slash' }))
            ),
            e('button', { type:'button', onClick:(ev)=>{ev.stopPropagation();if(confirm('삭제할까요?'))setThemes(themes.filter(t=>t!==tName));}, className:'text-slate-300 text-[10px] font-bold' }, '삭제')
          ),
          e('div', { className:`collapsible-content expand-down ${isCollapsed?'collapsed':'expanded'} px-5 pb-5` },
            e('div', { className:'chart-wrapper' }, e(TrendChart, { data:dailyScores, labels:dates, color:isPriority?'#f59e0b':'#6366f1', targetValue:activeTarget, averageValue:themeAnalysis.find(a=>a.name===tName)?.score||0, hasGoal:activeTarget>0, goalDates:gDates, periodScore, maxY:115 })),
            e('div', { className:'mt-1 space-y-0' }, tHabits.map(h=>e(HabitItem,{key:h.id,habit:h,dates,onAction:handleHabitAction})))
          )
        );
      }, [hiddenThemes, priorityThemes, habits, dates, collapsedStates, goals, themeAnalysis, themes, handleHabitAction, openModal, toggleCollapse, toggleThemeHide, togglePriority]);

      const renderCategoryChart = useCallback((cat) => {
        const catThemes = getCategoryThemes(cat);
        if(!catThemes.length) return null;
        const dailyScores = getCategoryDailyScores(cat);
        const maxScore = catThemes.length * 100;
        const avgScore = dates.length?Math.round(dailyScores.reduce((a,b)=>a+b,0)/dates.length):0;
        const isCollapsed = collapsedStates['cat_chart_'+cat.id];
        let activeTarget=0,gDates=[];
        goals.forEach(g=>{const item=g.targetItems.find(it=>it.type==='category'&&it.catId===cat.id);if(item&&item.target>activeTarget){activeTarget=item.target;gDates=getGoalDates(g.startDate,g.endDate);}});
        const periodScore=(()=>{ if(!gDates.length||!catThemes.length) return 0; const tot=catThemes.length*100; const ach=catThemes.reduce((a,tN)=>{const th=habits.filter(h=>h.theme===tN);if(!th.length)return a;return a+gDates.reduce((da,d)=>da+Math.round((th.filter(h=>h.checks[d]).length/th.length)*100),0);},0); return Math.round((ach/gDates.length/tot)*100); })();
        const ns = dailyScores.map(s=>maxScore>0?Math.round((s/maxScore)*100):0);
        const na = maxScore>0?Math.round((avgScore/maxScore)*100):0;
        return e('div', { key:'cat_chart_'+cat.id, className:'theme-card category-chart-card bg-white rounded-[2rem] card-elevated border border-slate-200 mb-3 overflow-hidden' },
          e('div', { className:'flex justify-between items-center p-4 cursor-pointer', onClick:()=>toggleCollapse('cat_chart_'+cat.id) },
            e('div', { className:'flex items-center gap-2' },
              e('i', { className:'fa-solid fa-chart-line text-violet-400 text-sm' }),
              e('h2', { className:'text-base font-black text-slate-700' }, cat.name+' 달성률'),
              e('span', { className:'text-[10px] font-black text-violet-400' }, isCollapsed?'▼':'▲')
            ),
            e('div', { className:'flex items-center gap-2' },
              e('span', { className:'text-[10px] font-bold text-slate-400' }, `${avgScore}/${maxScore}pt`),
              e('span', { className:'text-[10px] font-black text-violet-600 bg-violet-50 px-2 py-0.5 rounded-full' }, `${na}%`)
            )
          ),
          e('div', { className:`collapsible-content expand-down ${isCollapsed?'collapsed':'expanded'} px-4 pb-4` },
            e('div', { className:'text-[9px] text-slate-400 font-bold mb-1' }, `최대 ${maxScore}pt (테마 ${catThemes.length}개 × 100%)`),
            e('div', { className:'chart-wrapper' }, e(TrendChart, { data:ns, labels:dates, color:'#a78bfa', targetValue:activeTarget, averageValue:na, hasGoal:activeTarget>0, goalDates:gDates, periodScore, maxY:115 }))
          )
        );
      }, [getCategoryThemes, getCategoryDailyScores, dates, collapsedStates, goals, habits, toggleCollapse]);

      const handleAnalysisTouchStart = useCallback((ev) => { swipeStartX.current=ev.touches[0].clientX; swipeStartTime.current=Date.now(); swipeDeltaX.current=0; }, []);
      const handleAnalysisTouchMove = useCallback((ev) => {
        if(swipeStartX.current===null) return;
        const dx=ev.touches[0].clientX-swipeStartX.current; swipeDeltaX.current=dx;
        if(analysisPanelInnerRef.current){ const base=-analysisPage*100; const pct=base+(dx/analysisPanelInnerRef.current.parentElement.offsetWidth)*100; analysisPanelInnerRef.current.style.transition='none'; analysisPanelInnerRef.current.style.transform=`translateX(${pct}%)`; }
      }, [analysisPage]);
      const handleAnalysisTouchEnd = useCallback(() => {
        if(swipeStartX.current===null) return;
        const elapsed=Date.now()-swipeStartTime.current; const velocity=Math.abs(swipeDeltaX.current)/elapsed;
        let np=analysisPage;
        if(velocity>0.35||Math.abs(swipeDeltaX.current)>60){ if(swipeDeltaX.current<0&&analysisPage<1)np=1; else if(swipeDeltaX.current>0&&analysisPage>0)np=0; }
        swipeStartX.current=null; swipeDeltaX.current=0;
        if(analysisPanelInnerRef.current){ analysisPanelInnerRef.current.style.transition=''; analysisPanelInnerRef.current.style.transform=`translateX(${-np*100}%)`; }
        setAnalysisPage(np);
      }, [analysisPage]);

      /* ──────────────────────────────────────────────────────
         [PERF FIX] CategoryNode: memo()로 감싸서 불필요한 리렌더 방지
         → 부모가 리렌더돼도 props가 같으면 이 컴포넌트는 스킵
      ────────────────────────────────────────────────────── */
      const CategoryNode = useMemo(() => memo(({ category, depth=0 }) => {
        const isCollapsed = collapsedStates[category.id];
        const isHidden = hiddenCategories[category.id];
        const d = Math.min(depth, 3);

        const addThemeToCategory = (tName) => { setCategories(p=>{ const cl=removeThemeFromAllCategories(p,tName); return updateCategoryRecursive(cl,category.id,c=>({...c,themes:[...c.themes,tName].sort((a,b)=>themes.indexOf(a)-themes.indexOf(b))})); }); };
        const removeThemeFromCategory = (tName) => setCategories(p=>updateCategoryRecursive(p,category.id,c=>({...c,themes:c.themes.filter(t=>t!==tName)})));

        const getRootId = (list, targetId) => { for(const c of list){ if(c.id===targetId)return c.id; const f=getRootId(c.subCategories||[],targetId); if(f)return c.id; } return null; };
        const rootId = getRootId(categories, category.id);

        const collectAllThemesInTree = (list) => list.flatMap(c=>[...(c.themes||[]),...collectAllThemesInTree(c.subCategories||[])]);
        const themesInOtherTrees = useMemo(() => { const others=categories.filter(c=>c.id!==rootId); return new Set(collectAllThemesInTree(others)); }, [categories, rootId]);

        const collectSelfThemes = (cat) => [...(cat.themes||[]),...(cat.subCategories||[]).flatMap(collectSelfThemes)];
        const selfThemes = new Set(collectSelfThemes(category));
        const availableThemes = themes.filter(t=>!themesInOtherTrees.has(t)&&!selfThemes.has(t));

        const collectAllCatIds = (list) => list.flatMap(c=>[c.id,...collectAllCatIds(c.subCategories||[])]);
        const selfAndDescendants = new Set(collectAllCatIds([category]));
        const collectMovableTargets = (list, d2=0) => list.flatMap(c=>{ const entry={id:c.id,name:'　'.repeat(d2)+c.name}; return selfAndDescendants.has(c.id)?[]:[entry,...collectMovableTargets(c.subCategories||[],d2+1)]; });
        const movableTargets = collectMovableTargets(categories);

        const handleMoveCategory = (destId) => {
          if(!destId) return;
          setCategories(p => {
            const {newList, extracted} = extractCategory(p, category.id);
            if(!extracted) return p;
            if(destId==='__root__') return [...newList, extracted];
            const numId = isNaN(Number(destId)) ? destId : Number(destId);
            return updateCategoryRecursive(newList, numId, c=>({...c, subCategories:[...(c.subCategories||[]),extracted]}));
          });
        };

        const catThemes = getCategoryThemes(category);
        const sortedCatThemes = sortedThemesInCategory(category.themes||[]);

        return e('div', { style:{ marginLeft:depth>0?'10px':'0' } },
          e('div', { className:`category-depth-${d}${isHidden?' category-hidden':''}` },
            e('div', { className:`category-header-${d}` },
              e('div', { className:'flex items-center gap-2 flex-1', onClick:()=>toggleCollapseCategory(category.id, category) },
                e('i', { className:`fa-solid fa-folder${isCollapsed?'':'-open'} text-indigo-400 text-xs` }),
                e('span', { className:`font-black text-slate-700 text-${d===0?'sm':'xs'}` }, category.name),
                e('span', { className:'text-[9px] text-slate-400 font-bold ml-1' }, isCollapsed?'▼':'▲')
              ),
              e('div', { className:'flex gap-1 items-center flex-wrap', onClick:ev=>ev.stopPropagation() },
                e('select', { className:'text-[8px] font-bold bg-white border border-indigo-200 rounded-lg px-1 py-0.5 outline-none max-w-[58px]', value:'', onChange:(ev)=>{ if(ev.target.value) addThemeToCategory(ev.target.value); } },
                  e('option', {value:''}, '+ 테마'),
                  availableThemes.map(t=>e('option',{key:t,value:t},t))
                ),
                e('select', { className:'text-[8px] font-bold bg-white border border-slate-200 rounded-lg px-1 py-0.5 outline-none max-w-[58px]', value:'', onChange:(ev)=>handleMoveCategory(ev.target.value) },
                  e('option', {value:''}, '↗이동'),
                  e('option', {value:'__root__'}, '▲최상위'),
                  movableTargets.map(t=>e('option',{key:t.id,value:t.id},t.name))
                ),
                e('button', { type:'button', onClick:()=>openModal('ADD_SUB_CATEGORY',null,'',category.id), className:'text-[8px] font-bold text-indigo-500 bg-indigo-50 px-1.5 py-1 rounded-full' }, '+ 하위'),
                e('button', { type:'button', onClick:()=>openModal('CATEGORY_RENAME',category.id,category.name), className:'text-[8px] font-bold text-slate-500 bg-slate-100 px-1.5 py-1 rounded-full' }, '수정'),
                e('button', { type:'button', onClick:()=>toggleCategoryHide(category.id), className:`text-[8px] font-bold px-1.5 py-1 rounded-full ${isHidden?'bg-indigo-100 text-indigo-500':'bg-slate-100 text-slate-400'}` }, e('i', { className:'fa-solid fa-eye-slash text-[9px]' })),
                e('button', { type:'button', onClick:()=>{ if(confirm('카테고리를 삭제할까요?'))setCategories(p=>{ const rm=(list)=>list.filter(c=>c.id!==category.id).map(c=>({...c,subCategories:rm(c.subCategories||[])})); return rm(p); }); }, className:'text-slate-300 text-[9px] px-1' }, e('i', { className:'fa-solid fa-trash' }))
              )
            ),
            !isHidden && e('div', { className:`collapsible-content expand-down ${isCollapsed?'collapsed':'expanded'} category-body-${d}` },
              catThemes.length>0 && renderCategoryChart(category),
              (category.subCategories||[]).map(sub=>e(CategoryNode,{key:sub.id,category:sub,depth:depth+1})),
              sortedCatThemes.map(tName=>{ if(!themes.includes(tName)) return null; const isHid=hiddenThemes[tName]; return e('div',{key:tName}, !isHid&&e('div',{className:'flex justify-end mb-[-6px] mr-1 relative z-10'}, e('button',{type:'button',onClick:()=>removeThemeFromCategory(tName),className:'text-[8px] font-bold text-orange-400 bg-orange-50 border border-orange-200 px-2 py-0.5 rounded-full'},'↑ 빼기')), renderTheme(tName)); })
            )
          )
        );
      }), [collapsedStates, hiddenCategories, categories, themes, hiddenThemes, priorityThemes, getCategoryThemes, sortedThemesInCategory, renderCategoryChart, renderTheme, openModal, toggleCollapseCategory, toggleCategoryHide]);

      /* ── 메인 렌더 ── */
      return e('div', { className:'max-w-md mx-auto p-5 pb-32', onPointerMove:handlePointerMove, onPointerUp:handlePointerUp, onPointerCancel:handlePointerUp },
        e('header', { className:'mb-4 flex justify-between items-end' },
          e('h1', { className:'text-4xl font-black text-slate-900 tracking-tighter' }, 'Habit'),
          e(DayRangeInputs, { pastDays, futureDays, onPastChange: setPastDays, onFutureChange: setFutureDays })
        ),

        /* 분석 패널 */
        e('div', { className:'bg-white p-5 rounded-[2rem] mb-4 card-elevated border border-slate-200' },
          e('div', { className:'flex items-center justify-between mb-3' },
            e('div', { className:'flex items-center gap-3' },
              e('h3', { className:'text-[11px] font-black text-slate-400 uppercase tracking-wider' }, analysisPage===0?'Theme Analysis (%)':'Category Analysis (%)'),
              e('div', { className:'flex gap-1 items-center' }, e('div',{className:`analysis-dot ${analysisPage===0?'active':''}`}), e('div',{className:`analysis-dot ${analysisPage===1?'active':''}`}))
            ),
            analysisPage===0 && e('button', { type:'button', className:'text-[9px] font-black text-indigo-500 bg-indigo-50 px-2 py-1 rounded-full', onClick:()=>{ if(analysisSelectedThemes===null)setAnalysisSelectedThemes([]); else setAnalysisSelectedThemes(null); } }, analysisSelectedThemes===null?'전체':'선택중'),
            analysisPage===1 && e('button', { type:'button', className:'text-[9px] font-black text-violet-500 bg-violet-50 px-2 py-1 rounded-full', onClick:()=>{ if(analysisSelectedCats===null)setAnalysisSelectedCats([]); else setAnalysisSelectedCats(null); } }, analysisSelectedCats===null?'전체':'선택중')
          ),
          analysisPage===0 && e('div', { className:'flex flex-wrap gap-1.5 mb-3' },
            themes.filter(t=>!hiddenThemes[t]).map(t=>{ const isSel=analysisSelectedThemes===null||analysisSelectedThemes.includes(t); const isPri=priorityThemes.has(t); return e('button',{key:t,type:'button',onClick:()=>{ if(analysisSelectedThemes===null)setAnalysisSelectedThemes([t]); else setAnalysisSelectedThemes(p=>p.includes(t)?p.filter(x=>x!==t):[...p,t]); },className:`text-[9px] font-bold px-2 py-0.5 rounded-full border transition-all ${isSel?(isPri?'bg-amber-400 text-white border-amber-400':'bg-indigo-600 text-white border-indigo-600'):'bg-white text-slate-400 border-slate-200'}`},(isPri?'⭐':'')+t); })
          ),
          analysisPage===1 && e('div', { className:'flex flex-wrap gap-1.5 mb-3' },
            allCatsFlat.filter(c=>!hiddenCategories[c.id]&&getCategoryThemes(c).length>0).map(c=>{ const isSel=analysisSelectedCats===null||analysisSelectedCats.includes(c.id); return e('button',{key:c.id,type:'button',onClick:()=>{ if(analysisSelectedCats===null)setAnalysisSelectedCats([c.id]); else setAnalysisSelectedCats(p=>p.includes(c.id)?p.filter(x=>x!==c.id):[...p,c.id]); },className:`text-[9px] font-bold px-2 py-0.5 rounded-full border transition-all ${isSel?'bg-violet-600 text-white border-violet-600':'bg-white text-slate-400 border-slate-200'}`},c.name); })
          ),
          e('div', { className:'analysis-panel-wrap', onTouchStart:handleAnalysisTouchStart, onTouchMove:handleAnalysisTouchMove, onTouchEnd:handleAnalysisTouchEnd },
            e('div', { ref:analysisPanelInnerRef, className:'analysis-panel-inner', style:{transform:`translateX(${-analysisPage*100}%)`} },
              e('div', { className:'analysis-panel-page' },
                e('div', { className:'h-40' }, visibleThemesForAnalysis.length>0 ? e(AnalysisChart,{themes:visibleThemesForAnalysis,habits,dates,goals,priorityThemes}) : e('div',{className:'h-full flex items-center justify-center text-slate-300 text-sm font-bold'},'테마를 선택하세요'))
              ),
              e('div', { className:'analysis-panel-page' },
                e('div', { className:'h-40' }, visibleCatsForAnalysis.length>0 ? e(CategoryAnalysisChart,{visibleCats:visibleCatsForAnalysis,habits,dates,getCategoryThemes}) : e('div',{className:'h-full flex items-center justify-center text-slate-300 text-sm font-bold'},'카테고리를 선택하세요'))
              )
            )
          ),
          e('div', { className:'flex justify-center mt-2 text-[9px] text-slate-300 font-bold' }, '← 스와이프 →'),
          Object.values(hiddenThemes).some(v=>v) && e('div', { className:'mt-4' },
            e('button', { type:'button', className:'flex items-center gap-2 w-full px-3 py-2 bg-slate-100 rounded-2xl text-[10px] font-black text-slate-500 mb-2', onClick:()=>setHiddenFolderOpen(p=>!p) }, e('i',{className:'fa-solid fa-eye-slash text-slate-400'}), e('span',null,`숨긴 테마 (${themes.filter(t=>hiddenThemes[t]).length}개)`), e('span',{className:'ml-auto'},hiddenFolderOpen?'▲':'▼')),
            hiddenFolderOpen && e('div', { className:'flex flex-wrap gap-2 px-1' }, themes.filter(t=>hiddenThemes[t]).map(t=>e('button',{key:t,type:'button',onClick:()=>toggleThemeHide(t),className:'px-3 py-1 bg-slate-100 text-slate-500 rounded-full text-[10px] font-bold border border-slate-200 flex items-center gap-1'},e('i',{className:'fa-solid fa-eye text-slate-400 text-[8px]'}),t)))
          ),
          Object.values(hiddenCategories).some(v=>v) && e('div', { className:'mt-2' },
            e('button', { type:'button', className:'flex items-center gap-2 w-full px-3 py-2 bg-violet-50 rounded-2xl text-[10px] font-black text-violet-500 mb-2', onClick:()=>setHiddenCatFolderOpen(p=>!p) }, e('i',{className:'fa-solid fa-eye-slash text-violet-400'}), e('span',null,`숨긴 카테고리 (${Object.values(hiddenCategories).filter(Boolean).length}개)`), e('span',{className:'ml-auto'},hiddenCatFolderOpen?'▲':'▼')),
            hiddenCatFolderOpen && e('div', { className:'flex flex-wrap gap-2 px-1' }, allCatsFlat.filter(c=>hiddenCategories[c.id]).map(c=>e('button',{key:c.id,type:'button',onClick:()=>toggleCategoryHide(c.id),className:'px-3 py-1 bg-violet-100 text-violet-600 rounded-full text-[10px] font-bold border border-violet-200 flex items-center gap-1'},e('i',{className:'fa-solid fa-eye text-violet-400 text-[8px]'}),c.name)))
          )
        ),

        /* 목표 카드 */
        goals.map(g => {
          const isCollapsed=collapsedStates[g.id]; const progress=calculateGoalProgress(g);
          return e('div', { key:g.id, className:`bg-white ${isCollapsed?'p-4':'p-8'} rounded-[2.5rem] mb-4 card-elevated border border-slate-200 relative transition-all` },
            e('div', { className:`flex justify-between items-center ${isCollapsed?'mb-0':'mb-6'}` },
              e('div', { className:'flex items-center gap-2 flex-1 min-w-0', onClick:()=>toggleCollapse(g.id), style:{cursor:'pointer'} },
                e('span', { className:'flex-shrink-0 '+(isCollapsed?'text-lg':'text-2xl') }, '🎯'),
                e('h3', { className:`font-black text-slate-800 leading-tight ${isCollapsed?'text-base':'text-xl'}`, style:{wordBreak:'keep-all',overflowWrap:'break-word',display:'-webkit-box',WebkitLineClamp:isCollapsed?1:2,WebkitBoxOrient:'vertical',overflow:'hidden'} }, g.project||'새 목표'),
                isCollapsed && e('span', { className:'flex-shrink-0 text-sm font-black text-indigo-600 bg-indigo-50 px-2 py-0.5 rounded-full ml-1' }, `${Math.round(progress)}%`)
              ),
              e('div', { className:'flex gap-1.5 flex-wrap justify-end flex-shrink-0 ml-2' },
                e('button', { type:'button', onClick:addNewGoal, className:'px-2 py-1.5 rounded-full text-[9px] font-black bg-emerald-50 text-emerald-600' }, '+ 추가'),
                e('button', { type:'button', onClick:()=>toggleCollapse(g.id), className:'px-2.5 py-1.5 rounded-full text-[9px] font-black bg-slate-100 text-slate-500' }, isCollapsed?'▼':'▲'),
                e('button', { type:'button', onClick:()=>toggleGoalEditing(g.id), className:'px-2.5 py-1.5 rounded-full text-[9px] font-black bg-indigo-50 text-indigo-600' }, g.isEditing?'완료':'수정'),
                e('button', { type:'button', onClick:()=>deleteGoal(g.id), className:'px-2.5 py-1.5 rounded-full text-[9px] font-black bg-pink-50 text-pink-500' }, '삭제')
              )
            ),
            e('div', { className:`collapsible-content expand-down ${isCollapsed?'collapsed':'expanded'}` },
              !g.isEditing && e('div', { className:'flex justify-center mb-8' }, e(DonutGauge,{percent:progress})),
              e('div', { className:'space-y-6' },
                /* [PERF FIX] 목표 입력 필드: GoalInputField로 교체 - onBlur 방식 */
                e('div', null,
                  e('label',{className:'goal-label'},'프로젝트명'),
                  e(GoalInputField, { className:'goal-input', disabled:!g.isEditing, value:g.project, placeholder:'프로젝트 이름', onChange:(v)=>updateGoal(g.id,{project:v}) })
                ),
                e('div', null, e('label',{className:'goal-label'},'목표 수치'),
                  e('div', { className:'space-y-2' },
                    g.targetItems.map((item,idx)=>e('div',{key:idx,className:'goal-item-row'},
                      g.isEditing?e(React.Fragment,null,
                        e('select',{className:'bg-slate-100 p-2 rounded-xl text-xs font-bold outline-none flex-shrink-0',style:{width:'60px'},value:item.type||'theme',onChange:(ev)=>{const ni=[...g.targetItems];ni[idx]={...ni[idx],type:ev.target.value,theme:themes[0]||'',catId:flatCategoryList[0]?.id||'',catThemes:flatCategoryList[0]?.catThemes||[]};updateGoal(g.id,{targetItems:ni});}},e('option',{value:'theme'},'테마'),e('option',{value:'category'},'카테고리')),
                        (item.type||'theme')==='theme'
                          ?e('select',{className:'bg-slate-100 p-2 rounded-xl text-xs font-bold outline-none',style:{width:'90px',flexShrink:0},value:item.theme||'',onChange:(ev)=>{const ni=[...g.targetItems];ni[idx]={...ni[idx],theme:ev.target.value};updateGoal(g.id,{targetItems:ni});}},themes.map(t=>e('option',{key:t,value:t},t)))
                          :e('select',{className:'bg-slate-100 p-2 rounded-xl text-xs font-bold outline-none',style:{width:'90px',flexShrink:0},value:item.catId||'',onChange:(ev)=>{const f=flatCategoryList.find(c=>String(c.id)===ev.target.value);const ni=[...g.targetItems];ni[idx]={...ni[idx],catId:f?.id||'',catThemes:f?.catThemes||[]};updateGoal(g.id,{targetItems:ni});}},flatCategoryList.map(c=>e('option',{key:c.id,value:c.id},c.name))),
                        e('input',{type:'number',className:'bg-slate-100 p-2 rounded-xl text-sm font-bold text-center flex-shrink-0',style:{width:'52px'},value:item.target,onChange:(ev)=>{const ni=[...g.targetItems];ni[idx].target=parseInt(ev.target.value)||0;updateGoal(g.id,{targetItems:ni});}}),
                        e('span',{className:'font-bold text-sm flex-shrink-0'},'%'),
                        e('button',{type:'button',onClick:()=>updateGoal(g.id,{targetItems:g.targetItems.filter((_,i)=>i!==idx)}),className:'text-pink-500 flex-shrink-0 px-1 text-lg leading-none'},'✕')
                      ):e('div',{className:'text-base font-black text-slate-800'},`[${item.type==='category'?'카테고리':'테마'}] ${item.type==='category'?(flatCategoryList.find(c=>c.id===item.catId)?.name||item.catId):item.theme} ${item.target}%`)
                    )),
                    g.isEditing&&e('button',{type:'button',onClick:()=>updateGoal(g.id,{targetItems:[...g.targetItems,{type:'theme',theme:themes[0]||'',target:80}]}),className:'w-full py-2 border-2 border-dashed border-slate-200 rounded-xl text-slate-400 font-bold text-sm'},'+ 목표 추가')
                  )
                ),
                e('div', null,
                  e('label',{className:'goal-label'},'목표 이유'),
                  e(GoalInputField, { className:'goal-input text-base font-bold text-slate-600', isTextarea:true, disabled:!g.isEditing, value:g.reason, placeholder:'이유를 입력하세요', onChange:(v)=>updateGoal(g.id,{reason:v}) })
                ),
                e('div',{className:'flex gap-6'},
                  e('div',{className:'flex-1'},e('div',{className:'flex items-center justify-between mb-2'},e('label',{className:'goal-label !mb-0'},'시작일'),e('span',{className:'text-[10px] font-black text-indigo-500'},'START')),e('input',{type:g.isEditing?'date':'text',className:'goal-input !text-lg',disabled:!g.isEditing,value:g.startDate,onChange:(ev)=>updateGoal(g.id,{startDate:ev.target.value})})),
                  e('div',{className:'flex-1'},e('div',{className:'flex items-center justify-between mb-2'},e('label',{className:'goal-label !mb-0'},'목표일'),e('span',{className:'text-[10px] font-black text-emerald-500'},getDayDiffText(g.startDate,g.endDate))),e('input',{type:g.isEditing?'date':'text',className:'goal-input !text-lg',disabled:!g.isEditing,value:g.endDate,onChange:(ev)=>updateGoal(g.id,{endDate:ev.target.value})}))
                )
              )
            )
          );
        }),

        /* 카테고리 섹션 */
        e('div', { className:'mb-8' },
          e('div', { className:'flex justify-between items-center mb-4 px-2' },
            e('h3', { className:'text-[11px] font-black text-slate-400 uppercase tracking-widest' }, 'Nested Categories'),
            e('button', { type:'button', onClick:()=>openModal('ADD_ROOT_CATEGORY'), className:'text-indigo-600 font-bold text-[10px] bg-indigo-50 px-3 py-1.5 rounded-full' }, '+ 최상위 카테고리')
          ),
          categories.map(cat => e(CategoryNode, { key:cat.id, category:cat })),
          themes.filter(t=>!allCategoryThemes.has(t)).length>0 && e('div', { className:'mt-6' },
            e('h3', { className:'text-[11px] font-black text-slate-400 uppercase mb-4 px-2' }, 'Uncategorized Themes'),
            sortedThemesInCategory(themes.filter(t=>!allCategoryThemes.has(t))).map(tName=>renderTheme(tName))
          )
        ),

        /* 생각 노트 */
        e(NoteBox, { notes, setNotes }),

        /* 칠판 */
        e('div', { className:`blackboard-container ${boardFullscreen?'fullscreen':'mt-4'}` },
          e('div', { className:'flex justify-between items-end mb-2 px-2' },
            e('div', { className:'flex items-center gap-3' },
              e('h3', { className:'text-xl font-black text-slate-800' }, '칠판'),
              !boardFullscreen && e('button', { type:'button', onClick:()=>setBoardCollapsed(!boardCollapsed), className:'text-[10px] font-black text-indigo-600 bg-indigo-50 px-2 py-1 rounded-full' }, boardCollapsed?'펼치기 ▼':'접기 ▲')
            ),
            e('div', { className:'flex gap-4' },
              e('button', { type:'button', onClick:()=>setBoardFullscreen(!boardFullscreen), className:'text-slate-500' }, e('i',{className:`fa-solid ${boardFullscreen?'fa-compress':'fa-expand'}`})),
              e('button', { type:'button', onClick:()=>{ if(confirm('그림을 지울까요?')){ canvasRef.current.getContext('2d').clearRect(0,0,5000,5000); if(offscreenCanvasRef.current)offscreenCanvasRef.current.getContext('2d').clearRect(0,0,5000,5000); } }, className:'text-slate-400' }, e('i',{className:'fa-solid fa-trash-can'}))
            )
          ),
          e('div', { className:`collapsible-content ${(!boardFullscreen&&boardCollapsed)?'collapsed':'expanded'}` },
            e('div', { ref:boardAreaRef, className:'blackboard-area', onPointerDown:handleBoardPointerDown, onPointerMove:handleBoardPointerMove, onPointerUp:handleBoardPointerUp, onPointerLeave:handleBoardPointerUp, onTouchStart:handleBoardTouch, onTouchMove:handleBoardTouch, onTouchEnd:()=>{lastPinchDist.current=null;lastTouchPos.current={x:0,y:0};}, onClick:(ev)=>{ if(ev.target===ev.currentTarget||ev.target===boardContentRef.current||ev.target===canvasRef.current)setSelectedMemoId(null); } },
              e('div', { ref:boardContentRef, className:'board-content-wrapper', style:{transform:`translate(${boardTransform.x}px,${boardTransform.y}px) scale(${boardTransform.s})`} },
                e('canvas', { ref:canvasRef, width:5000, height:5000, className:'drawing-canvas', onPointerDown:startDrawing, onPointerMove:draw, onPointerUp:stopDrawing, onPointerLeave:stopDrawing, onClick:(ev)=>{ if(boardMode==='cursor'){ev.stopPropagation();setSelectedMemoId(null);} } }),
                memos.map(m=>e('div',{key:m.id,ref:(el)=>{if(el)domMemoRefs.current.set(m.id,el);else domMemoRefs.current.delete(m.id);},className:`memo-card ${m.locked?'locked':''} ${selectedMemoId===m.id?'active-border':''}`,style:{left:m.x,top:m.y,width:m.w||150,height:m.h||80},onPointerDown:(ev)=>handleMemoDown(ev,m)},
                  !m.locked&&e('div',{className:'resize-h',onPointerDown:(ev)=>{ev.stopPropagation();memoResizeIdRef.current=m.id;resizeDirRef.current='h';}}),
                  !m.locked&&e('div',{className:'resize-v',onPointerDown:(ev)=>{ev.stopPropagation();memoResizeIdRef.current=m.id;resizeDirRef.current='v';}}),
                  selectedMemoId===m.id&&e('div',{className:'memo-toolbar',onPointerDown:ev=>ev.stopPropagation()},
                    e('button',{type:'button',className:'tool-btn',onClick:()=>openModal('MEMO_EDIT',m.id,m.text)},'수정'),
                    e('button',{type:'button',className:`tool-btn ${m.locked?'active':''}`,onClick:()=>setMemos(p=>p.map(x=>x.id===m.id?{...x,locked:!x.locked}:x))},m.locked?'해제':'고정'),
                    e('button',{type:'button',className:'tool-btn danger',onClick:()=>setMemos(p=>p.filter(x=>x.id!==m.id))},'삭제')
                  ),
                  m.text
                ))
              )
            ),
            e('div', { className:'board-controls' },
              e('button',{type:'button',onClick:()=>setBoardMode('cursor'),className:`p-2 rounded-lg ${boardMode==='cursor'?'bg-indigo-600 text-white':'text-slate-500'}`},e('i',{className:'fa-solid fa-arrow-pointer'})),
              e('button',{type:'button',onClick:()=>setBoardMode('pen'),className:`p-2 rounded-lg ${boardMode==='pen'?'bg-indigo-600 text-white':'text-slate-500'}`},e('i',{className:'fa-solid fa-pen'})),
              e('button',{type:'button',onClick:()=>setBoardMode('eraser'),className:`p-2 rounded-lg ${boardMode==='eraser'?'bg-indigo-600 text-white':'text-slate-500'}`},e('i',{className:'fa-solid fa-eraser'})),
              boardMode==='pen'&&['#ef4444','#f59e0b','#10b981','#3b82f6','#ffffff'].map(c=>e('div',{key:c,className:`color-swatch ${penColor===c?'selected':''}`,style:{backgroundColor:c},onClick:()=>setPenColor(c)})),
              /* [PERF FIX] 칠판 커서 모드 입력 분리 */
              boardFullscreen&&boardMode==='cursor'&&e(BoardInputBar, { onAdd: handleAdd }),
              (boardMode==='pen'||boardMode==='eraser')&&e('div',{className:'flex-1 flex items-center justify-end gap-2 px-2'},e('input',{type:'range',min:1,max:boardMode==='eraser'?300:100,value:boardMode==='pen'?penSize:eraserSize,onChange:(ev)=>boardMode==='pen'?setPenSize(parseInt(ev.target.value)):setEraserSize(parseInt(ev.target.value)),className:'w-full'}),e('span',{className:'text-[10px] font-bold text-slate-600 min-w-[24px] text-right'},boardMode==='pen'?penSize:eraserSize))
            )
          )
        ),

        /* [PERF FIX] 하단 입력바 완전 분리 */
        !boardFullscreen && e(BottomBar, {
          themes,
          curTheme,
          onThemeChange: setCurTheme,
          onAdd: handleAdd,
          onOpenModal: openModal
        })
      );
    };

    ReactDOM.render(e(App), document.getElementById('root'));
    window.closeModal = () => document.getElementById('external-modal').classList.remove('active');
  </script>
</body>
</html>
