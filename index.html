<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Habit Tracker v78 - Goal-Period Based Gauge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  
  <style>
    body { font-family: -apple-system, sans-serif; background: #F8FAFC; margin: 0; overflow-x: hidden; -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .scroll-container { display: flex; gap: 4px; overflow-x: auto; flex-direction: row-reverse; flex: 1; padding: 1px 0 20px 0; -webkit-overflow-scrolling: touch; }
    .chart-wrapper { position: relative; height: 160px; width: 100%; display: flex; align-items: flex-end; gap: 12px; padding-bottom: 20px; }
    .chart-container { position: relative; height: 100%; flex: 1; min-width: 0; }
    .target-slider-container { width: 35px; height: 110px; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; flex-shrink: 0; margin-bottom: 25px; }
    input[type=range][orient=vertical] { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 4px; height: 100%; opacity: 0.6; }
    .chk-btn { transition: transform 0.1s ease; position: relative; border: 2px solid transparent; }
    .chk-btn.active { background-color: #6366f1 !important; }
    
    .theme-card { user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; touch-action: pan-y; position: relative; transition: transform 0.2s, box-shadow 0.2s; }
    .blackboard-container { position: relative; width: 100%; transition: all 0.3s ease; }
    .blackboard-container.fullscreen { position: fixed; inset: 0; z-index: 9000; background: #334155; padding: 10px; height: 100vh; display: flex; flex-direction: column; }
    .blackboard-area { background-color: #0f172a; border: 8px solid #1e293b; border-radius: 20px; height: 400px; position: relative; overflow: hidden; touch-action: none; box-shadow: inset 0 0 40px rgba(0,0,0,0.5); flex: 1; }
    .board-content-wrapper { width: 5000px; height: 5000px; position: absolute; top: 0; left: 0; transform-origin: 0 0; background-color: #334155; border: 4px dashed rgba(255,255,255,0.2); box-sizing: content-box; }
    .drawing-canvas { position: absolute; top: 0; left: 0; z-index: 1; touch-action: none; background: transparent; }
    
    .memo-card { 
      position: absolute; padding: 12px; background: #fef08a; color: #854d0e; font-weight: bold; font-size: 14px; border-radius: 4px; box-shadow: 2px 4px 6px rgba(0,0,0,0.3); cursor: grab; user-select: none; word-break: break-all; touch-action: none; z-index: 10; white-space: pre-wrap; display: flex; flex-direction: column; 
    }
    .memo-card.active-border { border: 2px solid #6366f1; }
    .memo-card.locked { border: 2px solid #ef4444; cursor: default; }

    .resize-h { position: absolute; right: 0; top: 0; width: 8px; height: 100%; cursor: ew-resize; z-index: 15; }
    .resize-v { position: absolute; bottom: 0; left: 0; width: 100%; height: 8px; cursor: ns-resize; z-index: 15; }

    .memo-toolbar { position: absolute; bottom: calc(100% + 10px); left: 50%; transform: translateX(-50%); background: white; border-radius: 8px; padding: 4px; display: flex; gap: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 50; white-space: nowrap; }
    .memo-toolbar::after { content: ''; position: absolute; top: 100%; left: 50%; margin-left: -6px; border-width: 6px; border-style: solid; border-color: white transparent transparent transparent; }
    .tool-btn { padding: 4px 8px; font-size: 12px; font-weight: bold; border-radius: 4px; background: #f1f5f9; color: #475569; }
    .tool-btn.danger { color: #ef4444; background: #fee2e2; }
    .tool-btn.active { color: white; background: #6366f1; }
    
    .board-controls { margin-top: 10px; padding: 8px 12px; background: #ffffff; border-radius: 20px; display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
    .color-swatch { width: 20px; height: 20px; border-radius: 50%; border: 1.5px solid #e2e8f0; cursor: pointer; flex-shrink: 0; }
    .color-swatch.selected { transform: scale(1.2); border-color: #6366f1; }

    #external-modal { position: fixed; inset: 0; z-index: 9999; display: none; align-items: center; justify-content: center; padding: 24px; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(4px); }
    #external-modal.active { display: flex; }
    .collapsible-content { transition: max-height 0.3s ease-out, opacity 0.2s ease; overflow: hidden; }
    .collapsed { max-height: 0; opacity: 1; pointer-events: none; }
    .expanded { max-height: 3000px; opacity: 1; }

    .goal-input { 
      width: 100%; background: #f1f5f9; border: 1px solid transparent; border-radius: 12px; padding: 10px 14px; font-size: 18px; font-weight: 800; color: #1e293b; outline: none; transition: all 0.2s; white-space: pre-wrap; display: block; overflow: hidden;
    }
    .goal-input:focus { border-color: #6366f1; background: white; }
    .goal-input:disabled { background: transparent; border-color: transparent; padding: 0; cursor: default; }
    .goal-label { font-size: 11px; font-weight: 800; color: #94a3b8; text-transform: uppercase; margin-bottom: 8px; display: block; }
    .goal-item-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <div id="external-modal">
    <div class="bg-white w-full max-w-sm rounded-[2.5rem] p-8 shadow-2xl">
      <h3 id="modal-title" class="text-2xl font-black mb-6 text-slate-800">ÏàòÏ†ï</h3>
      <textarea id="common-input" class="w-full bg-slate-100 p-4 rounded-2xl mb-8 outline-none font-bold text-lg min-h-[120px]" placeholder="ÎÇ¥Ïö© ÏûÖÎ†•..." autocomplete="off"></textarea>
      <div class="flex gap-3">
        <button onclick="closeModal()" class="flex-1 py-4 bg-slate-200 text-slate-600 rounded-2xl font-bold">Ï∑®ÏÜå</button>
        <button id="modal-submit-btn" class="flex-1 py-4 bg-indigo-600 text-white rounded-2xl font-bold">ÌôïÏù∏</button>
      </div>
    </div>
  </div>

  <script>
    const e = React.createElement;
    const { useState, useEffect, useRef, useCallback, memo, useMemo } = React;

    const getInitialData = (k, f) => { const s = localStorage.getItem(k); return s ? JSON.parse(s) : f; };

    // ÎèÑÎÑõ Ï∞®Ìä∏ Ïª¥Ìè¨ÎÑåÌä∏
    const DonutGauge = memo(({ percent }) => {
      const canvasRef = useRef(null);
      const chartRef = useRef(null);
      const displayPercent = Math.min(100, Math.max(0, percent));

      useEffect(() => {
        if (chartRef.current) chartRef.current.destroy();
        chartRef.current = new Chart(canvasRef.current.getContext('2d'), {
          type: 'doughnut',
          data: {
            datasets: [{
              data: [displayPercent, 100 - displayPercent],
              backgroundColor: ['#6366f1', '#f1f5f9'],
              borderWidth: 0,
              circumference: 360,
              rotation: 0,
              cutout: '75%'
            }]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            plugins: { tooltip: { enabled: false }, legend: { display: false } },
            animation: { duration: 1000 }
          }
        });
      }, [displayPercent]);
      return e('div', { className: 'relative w-24 h-24' },
        e('canvas', { ref: canvasRef }),
        e('div', { className: 'absolute inset-0 flex items-center justify-center' },
          e('span', { className: 'text-lg font-black text-slate-800' }, `${Math.round(displayPercent)}%`)
        )
      );
    });

    const AnalysisChart = memo(({ data }) => {
      const canvasRef = useRef(null);
      const chartRef = useRef(null);
      useEffect(() => {
        if (chartRef.current) chartRef.current.destroy();
        chartRef.current = new Chart(canvasRef.current.getContext('2d'), {
          type: 'bar',
          data: {
            labels: data.map(d => d.name),
            datasets: [{ data: data.map(d => d.score), backgroundColor: '#6366f1', borderRadius: 8, barThickness: 20 }]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            layout: { padding: { bottom: 10 } },
            scales: {
              y: { beginAtZero: true, max: 100, ticks: { stepSize: 20, autoSkip: false, font: { size: 10 } } },
              x: { grid: { display: false }, ticks: { font: { size: 9, weight: 'bold' }, maxRotation: 45, minRotation: 45, autoSkip: false } }
            }
          }
        });
      }, [data]);
      return e('canvas', { ref: canvasRef });
    });

    const TrendChart = memo(({ data, labels, color, targetValue, averageValue }) => {
      const canvasRef = useRef(null);
      const chartRef = useRef(null);
      useEffect(() => {
        if (chartRef.current) chartRef.current.destroy();
        chartRef.current = new Chart(canvasRef.current.getContext('2d'), {
          type: 'line',
          data: {
            labels: labels.map(l => l.split('-').slice(1).join('.')),
            datasets: [
              { label: 'ÌèâÍ∑†', data: new Array(data.length).fill(averageValue), borderColor: color, borderWidth: 1, pointRadius: 0, fill: false },
              { label: 'Î™©Ìëú', data: new Array(data.length).fill(targetValue), borderColor: '#ef4444', borderWidth: 1, borderDash: [4, 4], pointRadius: 0, fill: false },
              { data: data, borderColor: color, backgroundColor: color + '20', borderWidth: 2, pointRadius: 0, fill: true, tension: 0.4 }
            ]
          },
          options: {
            responsive: true, maintainAspectRatio: false, animation: false,
            plugins: { legend: { display: false } },
            scales: {
              x: { display: true, grid: { display: false }, ticks: { font: { size: 8 }, maxRotation: 0, minRotation: 0 } },
              y: { display: false, min: 0, max: 110 }
            }
          }
        });
      }, [data, labels, color, targetValue, averageValue]);
      return e('div', { className: 'chart-container' }, e('canvas', { ref: canvasRef }));
    });

    const HabitItem = memo(({ habit, dates, onAction }) => {
      const rangeCount = dates.filter(d => habit.checks[d]).length;
      return e('div', { className: 'flex flex-col' },
        e('div', { className: 'flex items-center justify-between min-h-[14px] mt-2' }, 
          e('div', { className: 'flex items-center gap-2 flex-1 min-w-0' }, 
            e('div', { className: 'text-[11px] font-black text-slate-700 truncate' }, habit.name),
            e('button', { onClick: () => onAction(habit.id, 'EDIT_NAME'), className: 'text-[8px] text-indigo-300 font-bold' }, 'ÏàòÏ†ï'),
            e('button', { onClick: () => onAction(habit.id, 'DELETE'), className: 'text-[8px] text-pink-300 font-bold' }, 'ÏßÄÏö∞Í∏∞')
          ),
          e('div', { className: 'text-[9px] font-black text-slate-800' }, `${rangeCount}Ìöå / ${habit.total || 0}`)
        ),
        e('div', { className: 'scroll-container no-scrollbar' }, 
          [...dates].reverse().map(d => e('button', {
            key: d, onClick: (ev) => { ev.stopPropagation(); onAction(habit.id, d); },
            className: `w-7 h-7 rounded-lg flex-shrink-0 chk-btn ${habit.checks[d] ? 'active' : 'bg-slate-100'}`
          }, habit.checks[d] && e('span',{className:'text-white text-[10px] font-bold'},'‚úì')))
        )
      );
    });

    const App = () => {
      const [habits, setHabits] = useState(() => getInitialData('habits_final', []));
      const [themes, setThemes] = useState(() => getInitialData('themes_final', []));
      const [themeTargets, setThemeTargets] = useState(() => getInitialData('targets_final', {}));
      const [daysRange, setDaysRange] = useState(() => getInitialData('days_range_final', 14));
      
      // ÏûÖÎ†•ÏÉÅÌÉúÎ•º Ï¥àÍ∏∞Ìôî (ÌîÑÎ°úÏ†ùÌä∏Î™Ö, ÏãúÏûëÏùº, Î™©ÌëúÏùº ÎπÑÏõÄ)
      const [goal, setGoal] = useState(() => getInitialData('goal_settings_v3', {
        project: '', 
        targetItems: [], 
        reason: '', 
        startDate: '', 
        endDate: ''
      }));
      const [isGoalEditing, setIsGoalEditing] = useState(false);

      const [memos, setMemos] = useState(() => getInitialData('memos_final', []));
      const [selectedMemoId, setSelectedMemoId] = useState(null);
      const [boardMode, setBoardMode] = useState('cursor');
      const [penColor, setPenColor] = useState('#ef4444');
      const [penSize, setPenSize] = useState(5);
      const [eraserSize, setEraserSize] = useState(20);
      const [boardFullscreen, setBoardFullscreen] = useState(false);
      const [boardTransform, setBoardTransform] = useState(() => getInitialData('board_transform_final', { x: 0, y: 0, s: 10 }));
      const [collapsedThemes, setCollapsedThemes] = useState({});
      const [curTheme, setCurTheme] = useState(''); 
      const [inputVal, setInputVal] = useState('');
      const [modalState, setModalState] = useState({ type: null, targetId: null });

      const reasonTextareaRef = useRef(null);
      const boardAreaRef = useRef(null);
      const canvasRef = useRef(null);
      const lastPinchDist = useRef(null);
      const lastTouchPos = useRef({ x: 0, y: 0 });
      const memoDragIdRef = useRef(null);
      const memoResizeIdRef = useRef(null);
      const resizeDirRef = useRef(null); 
      const memoOffsetRef = useRef({ x: 0, y: 0 });
      const isPanningRef = useRef(false);
      const isDrawingRef = useRef(false);
      const requestRef = useRef(null);

      const autoResize = (ref) => {
        if (ref.current) {
          ref.current.style.height = 'auto';
          ref.current.style.height = ref.current.scrollHeight + 'px';
        }
      };

      useEffect(() => { autoResize(reasonTextareaRef); }, [goal.reason, isGoalEditing]);

      useEffect(() => {
        localStorage.setItem('habits_final', JSON.stringify(habits));
        localStorage.setItem('themes_final', JSON.stringify(themes));
        localStorage.setItem('memos_final', JSON.stringify(memos));
        localStorage.setItem('targets_final', JSON.stringify(themeTargets));
        localStorage.setItem('days_range_final', JSON.stringify(daysRange));
        localStorage.setItem('goal_settings_v3', JSON.stringify(goal));
        localStorage.setItem('board_transform_final', JSON.stringify(boardTransform));
      }, [habits, themes, memos, themeTargets, daysRange, goal, boardTransform]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (canvas && canvas.getContext) {
          const ctx = canvas.getContext('2d');
          const savedImg = localStorage.getItem('board_drawing_v3');
          if (savedImg) { 
            const img = new Image(); img.src = savedImg; 
            img.onload = () => ctx.drawImage(img, 0, 0); 
          }
        }
      }, []);

      const dates = useMemo(() => Array.from({length: daysRange}, (_, i) => {
        const d = new Date(); 
        d.setDate(d.getDate() - (daysRange - 1 - i));
        return d.toISOString().split('T')[0];
      }), [daysRange]);

      const goalDates = useMemo(() => {
        const start = new Date(goal.startDate);
        const end = new Date(goal.endDate);
        const arr = [];
        if (isNaN(start) || isNaN(end) || start > end) return [];
        
        let curr = new Date(start);
        while (curr <= end) {
          arr.push(curr.toISOString().split('T')[0]);
          curr.setDate(curr.getDate() + 1);
        }
        return arr;
      }, [goal.startDate, goal.endDate]);

      const themeAnalysis = useMemo(() => themes.map(t => {
        const th = habits.filter(h => h.theme === t);
        if (!th.length) return { name: t, score: 0 };
        const tc = th.reduce((a, h) => a + dates.filter(d => h.checks[d]).length, 0);
        return { name: t, score: Math.round((tc / (th.length * dates.length)) * 100) };
      }), [themes, habits, dates]);

      const totalGoalProgress = useMemo(() => {
        if (!goal.targetItems.length || !goalDates.length) return 0;
        
        let totalCurrentScore = 0;
        let totalTargetScore = 0;

        goal.targetItems.forEach(item => {
          const themeHabits = habits.filter(h => h.theme === item.theme);
          if (themeHabits.length === 0) return;

          const totalChecksInPeriod = themeHabits.reduce((acc, h) => {
            return acc + goalDates.filter(d => h.checks[d]).length;
          }, 0);

          const totalPossibleInPeriod = themeHabits.length * goalDates.length;
          const currentThemeScore = (totalChecksInPeriod / totalPossibleInPeriod) * 100;
          
          totalCurrentScore += currentThemeScore;
          totalTargetScore += item.target;
        });

        return totalTargetScore > 0 ? (totalCurrentScore / totalTargetScore) * 100 : 0;
      }, [goal.targetItems, goalDates, habits]);

      const handleAddTargetItem = () => {
        setGoal({
          ...goal,
          targetItems: [...goal.targetItems, { theme: themes[0] || '', target: 80 }]
        });
      };

      const updateTargetItem = (index, field, value) => {
        const newItems = [...goal.targetItems];
        newItems[index][field] = value;
        setGoal({ ...goal, targetItems: newItems });
      };

      const removeTargetItem = (index) => {
        setGoal({ ...goal, targetItems: goal.targetItems.filter((_, i) => i !== index) });
      };

      const getCanvasPos = (e) => {
        const rect = boardAreaRef.current.getBoundingClientRect();
        return {
          x: (e.clientX - rect.left - boardTransform.x) / boardTransform.s,
          y: (e.clientY - rect.top - boardTransform.y) / boardTransform.s
        };
      };

      const handleAdd = useCallback(() => {
        const val = inputVal.trim();
        if (!val) return;
        if (curTheme === 'Ïπ†Ìåê' || boardFullscreen) {
          const areaWidth = boardAreaRef.current.clientWidth;
          const areaHeight = boardAreaRef.current.clientHeight;
          const spawnX = (areaWidth / 2 - boardTransform.x) / boardTransform.s - 75; 
          const spawnY = (areaHeight / 2 - boardTransform.y) / boardTransform.s - 40;
          setMemos(p => [...p, { id: Date.now(), text: val, x: spawnX, y: spawnY, w: 150, h: 80, locked: false }]);
        } else if (curTheme) {
          setHabits(p => [...p, { id: Date.now(), name: val, theme: curTheme, checks: {}, total: 0 }]);
        } else {
          if (!themes.includes(val)) { setThemes(p => [...p, val]); setCurTheme(val); }
        }
        setInputVal('');
      }, [inputVal, curTheme, themes, boardFullscreen, boardTransform]);

      const handlePointerMove = (e) => {
        const pos = getCanvasPos(e);
        if (memoDragIdRef.current !== null) {
          setMemos(prev => prev.map(m => m.id === memoDragIdRef.current ? { ...m, x: pos.x - memoOffsetRef.current.x, y: pos.y - memoOffsetRef.current.y } : m));
        } else if (memoResizeIdRef.current !== null) {
          setMemos(prev => prev.map(m => {
            if (m.id === memoResizeIdRef.current) {
              if (resizeDirRef.current === 'h') return { ...m, w: Math.max(50, pos.x - m.x) };
              if (resizeDirRef.current === 'v') return { ...m, h: Math.max(30, pos.y - m.y) };
            }
            return m;
          }));
        }
      };

      const handlePointerUp = () => { memoDragIdRef.current = null; memoResizeIdRef.current = null; resizeDirRef.current = null; };
      const handleBoardPointerDown = (e) => { if (boardMode !== 'cursor' || memoDragIdRef.current !== null || memoResizeIdRef.current !== null) return; isPanningRef.current = true; lastTouchPos.current = { x: e.clientX, y: e.clientY }; };
      const handleBoardPointerMove = (e) => { if (!isPanningRef.current || boardMode !== 'cursor') return; const dx = e.clientX - lastTouchPos.current.x; const dy = e.clientY - lastTouchPos.current.y; setBoardTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy })); lastTouchPos.current = { x: e.clientX, y: e.clientY }; };
      const handleBoardPointerUp = () => { isPanningRef.current = false; };
      const handleBoardTouch = (e) => {
        if (boardMode !== 'cursor' || memoDragIdRef.current !== null || memoResizeIdRef.current !== null) return;
        if (e.touches.length === 2) {
          const t1 = e.touches[0]; const t2 = e.touches[1];
          const dist = Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY);
          const midX = (t1.clientX + t2.clientX) / 2; const midY = (t1.clientY + t2.clientY) / 2;
          const rect = boardAreaRef.current.getBoundingClientRect();
          const localMidX = midX - rect.left; const localMidY = midY - rect.top;
          if (lastPinchDist.current !== null) {
            const delta = dist / lastPinchDist.current;
            const newScale = Math.min(Math.max(boardTransform.s * delta, 0.1), 10);
            const Px = (localMidX - boardTransform.x) / boardTransform.s;
            const Py = (localMidY - boardTransform.y) / boardTransform.s;
            setBoardTransform({ x: localMidX - Px * newScale, y: localMidY - Py * newScale, s: newScale });
          }
          lastPinchDist.current = dist;
        }
      };

      const handleMemoDown = (e, memo) => { e.stopPropagation(); setSelectedMemoId(memo.id); if (boardMode !== 'cursor' || memo.locked) return; const rect = e.currentTarget.getBoundingClientRect(); memoOffsetRef.current = { x: (e.clientX - rect.left) / boardTransform.s, y: (e.clientY - rect.top) / boardTransform.s }; memoDragIdRef.current = memo.id; };
      const startDrawing = (e) => { if (boardMode === 'cursor') return; const ctx = canvasRef.current.getContext('2d'); const pos = getCanvasPos(e); ctx.beginPath(); ctx.moveTo(pos.x, pos.y); ctx.lineCap = 'round'; ctx.lineJoin = 'round'; if (boardMode === 'eraser') { ctx.globalCompositeOperation = 'destination-out'; ctx.lineWidth = eraserSize; } else { ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = penColor; ctx.lineWidth = penSize; } isDrawingRef.current = true; };
      const draw = (e) => { if (!isDrawingRef.current) return; if (requestRef.current) cancelAnimationFrame(requestRef.current); requestRef.current = requestAnimationFrame(() => { const ctx = canvasRef.current.getContext('2d'); const pos = getCanvasPos(e); ctx.lineTo(pos.x, pos.y); ctx.stroke(); }); };
      const stopDrawing = () => { if(isDrawingRef.current) { isDrawingRef.current = false; if (requestRef.current) cancelAnimationFrame(requestRef.current); localStorage.setItem('board_drawing_v3', canvasRef.current.toDataURL()); } };

      const openModal = (type, targetId, val) => {
        setModalState({ type, targetId });
        document.getElementById('modal-title').innerText = type === 'THEME_ADD' ? 'ÏÉà ÌÖåÎßà Ï∂îÍ∞Ä' : (type.includes('THEME') ? 'ÌÖåÎßà ÏàòÏ†ï' : 'ÏàòÏ†ï');
        document.getElementById('common-input').value = val || '';
        document.getElementById('external-modal').classList.add('active');
      };

      const handleModalSubmit = useCallback(() => {
        const val = document.getElementById('common-input').value.trim(); if (!val) return;
        if (modalState.type === 'THEME_EDIT') {
          setThemes(p => p.map(t => t === modalState.targetId ? val : t));
          setHabits(p => p.map(h => h.theme === modalState.targetId ? {...h, theme: val} : h));
        } else if (modalState.type === 'HABIT_EDIT') {
          setHabits(p => p.map(h => h.id === modalState.targetId ? {...h, name: val} : h));
        } else if (modalState.type === 'MEMO_EDIT') {
          setMemos(p => p.map(m => m.id === modalState.targetId ? {...m, text: val} : m));
        } else if (modalState.type === 'THEME_ADD') { setThemes(p => [...p, val]); setCurTheme(val); }
        window.closeModal();
      }, [modalState]);

      useEffect(() => { document.getElementById('modal-submit-btn').onclick = handleModalSubmit; }, [handleModalSubmit]);

      return e('div', { className: 'max-w-md mx-auto p-5 pb-32', onPointerMove: handlePointerMove, onPointerUp: handlePointerUp },
        e('header', { className: 'mb-4 flex justify-between items-end' }, 
          e('h1', { className: 'text-4xl font-black text-slate-900 tracking-tighter' }, 'Habit'), 
          e('div', { className: 'bg-white px-4 py-2 rounded-2xl shadow-sm border border-slate-50 flex items-center gap-3' },
            e('span', { className: 'text-[10px] font-black text-slate-400 uppercase' }, 'Í∏∞Í∞Ñ'),
            e('input', { type: 'number', className: 'w-8 text-center font-bold text-indigo-600 outline-none', value: daysRange, onChange: (ev) => setDaysRange(Math.max(1, parseInt(ev.target.value) || 1)) })
          )
        ),
        
        e('div', { className: 'bg-white p-5 rounded-[2rem] mb-4 shadow-sm border border-slate-50' },
          e('h3', { className: 'text-[11px] font-black text-slate-400 mb-4 uppercase tracking-wider' }, 'Theme Analysis (%)'),
          e('div', { className: 'h-40' }, e(AnalysisChart, { data: themeAnalysis }))
        ),

        e('div', { className: 'bg-white p-8 rounded-[2.5rem] mb-4 shadow-sm border border-slate-50' },
          e('div', { className: 'flex justify-between items-start mb-8' },
            e('div', { className: 'flex items-center gap-2' },
              e('span', { className: 'text-2xl' }, 'üéØ'),
              e('h3', { className: 'text-2xl font-black text-slate-800' }, 'Î™©Ìëú ÏÑ§Ï†ï')
            ),
            e('button', { 
              onClick: () => setIsGoalEditing(!isGoalEditing),
              className: 'px-5 py-2 rounded-full text-sm font-bold bg-slate-50 text-slate-500'
            }, isGoalEditing ? 'ÏôÑÎ£å' : 'ÏàòÏ†ïÌïòÍ∏∞')
          ),
          
          !isGoalEditing && e('div', { className: 'flex justify-center mb-8' },
            e(DonutGauge, { percent: totalGoalProgress })
          ),

          e('div', { className: 'space-y-8' },
            e('div', null,
              e('label', { className: 'goal-label' }, 'ÌîÑÎ°úÏ†ùÌä∏Î™Ö'),
              e('input', { 
                className: 'goal-input', disabled: !isGoalEditing, value: goal.project, placeholder: 'ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ',
                onChange: (ev) => setGoal({...goal, project: ev.target.value}) 
              })
            ),
            
            e('div', null,
              e('label', { className: 'goal-label' }, 'ÏûêÏÑ∏Ìïú Î™©Ìëú Îã¨ÏÑ± ÏàòÏπò'),
              e('div', { className: 'space-y-2' },
                goal.targetItems.map((item, idx) => e('div', { key: idx, className: 'goal-item-row' },
                  isGoalEditing ? e(React.Fragment, null,
                    e('select', { 
                      className: 'flex-1 bg-slate-100 p-2 rounded-xl text-sm font-bold outline-none',
                      value: item.theme, onChange: (ev) => updateTargetItem(idx, 'theme', ev.target.value)
                    }, themes.map(t => e('option', { key: t, value: t }, t))),
                    e('input', { 
                      type: 'number', className: 'w-16 bg-slate-100 p-2 rounded-xl text-sm font-bold text-center',
                      value: item.target, onChange: (ev) => updateTargetItem(idx, 'target', parseInt(ev.target.value) || 0)
                    }),
                    e('span', { className: 'font-bold' }, '%'),
                    e('button', { onClick: () => removeTargetItem(idx), className: 'text-pink-500 px-2' }, '‚úï')
                  ) : e('div', { className: 'text-xl font-black text-slate-800' }, `${item.theme} ${item.target}%`)
                )),
                isGoalEditing && e('button', { 
                  onClick: handleAddTargetItem, 
                  className: 'w-full py-2 border-2 border-dashed border-slate-200 rounded-xl text-slate-400 font-bold text-sm' 
                }, '+ Î™©Ìëú ÌÖåÎßà Ï∂îÍ∞Ä')
              )
            ),

            e('div', null,
              e('label', { className: 'goal-label' }, 'Î™©Ìëú ÏÑ§Ï†ï Ïù¥Ïú†'),
              e('textarea', { 
                ref: reasonTextareaRef, className: 'goal-input text-base font-bold text-slate-600', disabled: !isGoalEditing, value: goal.reason, 
                placeholder: 'Î™©Ìëú ÏÑ§Ï†ï Ïù¥Ïú†Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî',
                onChange: (ev) => setGoal({...goal, reason: ev.target.value}) 
              })
            ),

            e('div', { className: 'flex gap-6' },
              e('div', { className: 'flex-1' },
                e('label', { className: 'goal-label' }, 'ÏãúÏûëÏùº'),
                e('input', { 
                  type: isGoalEditing ? 'date' : 'text', className: 'goal-input !text-lg', disabled: !isGoalEditing, 
                  value: goal.startDate, onChange: (ev) => setGoal({...goal, startDate: ev.target.value}) 
                })
              ),
              e('div', { className: 'flex-1' },
                e('label', { className: 'goal-label' }, 'Î™©ÌëúÏùº'),
                e('input', { 
                  type: isGoalEditing ? 'date' : 'text', className: 'goal-input !text-lg', disabled: !isGoalEditing, 
                  value: goal.endDate, onChange: (ev) => setGoal({...goal, endDate: ev.target.value}) 
                })
              )
            )
          )
        ),

        themes.map((tName) => {
          const tHabits = habits.filter(h => h.theme === tName);
          const dailyScores = dates.map(d => tHabits.length ? Math.round((tHabits.filter(h => h.checks[d]).length / tHabits.length) * 100) : 0);
          const isCollapsed = collapsedThemes[tName] !== false;
          return e('div', { key: tName, className: `theme-card bg-white rounded-[2rem] p-5 shadow-sm border border-slate-50 mb-3` },
            e('div', { className: 'flex justify-between items-center mb-1' },
              e('div', { className: 'flex items-center gap-2' },
                e('h2', { className: 'text-lg font-black text-slate-800' }, tName),
                e('button', { onClick: () => openModal('THEME_EDIT', tName, tName), className: 'text-indigo-400 text-[9px] font-bold px-1.5 py-0.5 bg-indigo-50 rounded-md' }, 'ÏàòÏ†ï'),
                e('button', { onClick: () => setCollapsedThemes(p => ({...p, [tName]: !isCollapsed})), className: 'text-[10px] font-black text-indigo-600 bg-indigo-50 px-2 py-1 rounded-full' }, isCollapsed ? 'ÌéºÏπòÍ∏∞ ‚ñº' : 'Ï†ëÍ∏∞ ‚ñ≤')
              ),
              e('button', { onClick: () => confirm('ÏÇ≠Ï†úÌï†ÍπåÏöî?') && setThemes(themes.filter(t => t !== tName)), className: 'text-slate-300 text-[10px] font-bold pr-2' }, 'ÏÇ≠Ï†ú')
            ),
            e('div', { className: `collapsible-content ${isCollapsed ? 'collapsed' : 'expanded'}` },
              e('div', { className: 'chart-wrapper' },
                e(TrendChart, { data: dailyScores, labels: dates, color: '#6366f1', targetValue: themeTargets[tName] || 50, averageValue: themeAnalysis.find(a => a.name === tName)?.score || 0 }),
                e('div', { className: 'target-slider-container' },
                  e('input', { type: 'range', min: '0', max: '100', orient: 'vertical', value: themeTargets[tName] || 50, onChange: (ev) => setThemeTargets({...themeTargets, [tName]: parseInt(ev.target.value)}) }),
                  e('span', { className: 'text-[9px] font-black mt-1 text-indigo-600' }, `${themeTargets[tName] || 50}%`)
                )
              ),
              e('div', { className: 'mt-1 space-y-0' }, tHabits.map(h => e(HabitItem, { key: h.id, habit: h, dates, onAction: (hid, act) => {
                if (act === 'DELETE') confirm('ÏäµÍ¥ÄÏùÑ ÏÇ≠Ï†úÌï†ÍπåÏöî?') && setHabits(habits.filter(x => x.id !== hid));
                else if (act === 'EDIT_NAME') openModal('HABIT_EDIT', hid, habits.find(x => x.id === hid).name);
                else setHabits(habits.map(x => x.id === hid ? {...x, checks: {...x.checks, [act]: !x.checks[act]}, total: x.total + (x.checks[act] ? -1 : 1)} : x));
              }})))
            )
          );
        }),

        e('div', { className: `blackboard-container ${boardFullscreen ? 'fullscreen' : 'mt-8'}` },
          e('div', { className: 'flex justify-between items-end mb-2 px-2' },
            e('h3', { className: 'text-xl font-black text-slate-800' }, 'Ïπ†Ìåê'),
            e('div', { className: 'flex gap-4' },
                e('button', { onClick: () => setBoardFullscreen(!boardFullscreen), className: 'text-slate-500' }, e('i', { className: `fa-solid ${boardFullscreen ? 'fa-compress' : 'fa-expand'}` })),
                e('button', { onClick: () => confirm('Í∑∏Î¶ºÏùÑ Î™®Îëê ÏßÄÏö∏ÍπåÏöî?') && canvasRef.current.getContext('2d').clearRect(0,0,5000,5000), className: 'text-slate-400' }, e('i', { className: 'fa-solid fa-trash-can' }))
            )
          ),
          e('div', { 
            ref: boardAreaRef, className: 'blackboard-area', 
            onPointerDown: handleBoardPointerDown, onPointerMove: handleBoardPointerMove, onPointerUp: handleBoardPointerUp, onPointerLeave: handleBoardPointerUp,
            onTouchStart: handleBoardTouch, onTouchMove: handleBoardTouch, onTouchEnd: () => { lastPinchDist.current = null; lastTouchPos.current = { x: 0, y: 0 }; }, 
            onClick: (ev) => { if(ev.target === ev.currentTarget) setSelectedMemoId(null); } 
          },
            e('div', { className: 'board-content-wrapper', style: { transform: `translate(${boardTransform.x}px, ${boardTransform.y}px) scale(${boardTransform.s})` } },
              e('canvas', { ref: canvasRef, width: 5000, height: 5000, className: 'drawing-canvas', onPointerDown: startDrawing, onPointerMove: draw, onPointerUp: stopDrawing, onPointerLeave: stopDrawing }),
              memos.map(m => e('div', { 
                  key: m.id, 
                  className: `memo-card ${m.locked ? 'locked' : ''} ${selectedMemoId === m.id ? 'active-border' : ''}`, 
                  style: { left: m.x, top: m.y, width: m.w || 150, height: m.h || 80 }, 
                  onPointerDown: (ev) => handleMemoDown(ev, m) 
                }, 
                !m.locked && e('div', { className: 'resize-h', onPointerDown: (ev) => { ev.stopPropagation(); memoResizeIdRef.current = m.id; resizeDirRef.current = 'h'; } }),
                !m.locked && e('div', { className: 'resize-v', onPointerDown: (ev) => { ev.stopPropagation(); memoResizeIdRef.current = m.id; resizeDirRef.current = 'v'; } }),
                selectedMemoId === m.id && e('div', { className: 'memo-toolbar', onPointerDown: e => e.stopPropagation() },
                  e('button', { className: 'tool-btn', onClick: () => openModal('MEMO_EDIT', m.id, m.text) }, 'ÏàòÏ†ï'),
                  e('button', { className: `tool-btn ${m.locked ? 'active' : ''}`, onClick: () => setMemos(p => p.map(x => x.id === m.id ? {...x, locked: !x.locked} : x)) }, m.locked ? 'Ìï¥Ï†ú' : 'Í≥†Ï†ï'),
                  e('button', { className: 'tool-btn danger', onClick: () => setMemos(p => p.filter(x => x.id !== m.id)) }, 'ÏÇ≠Ï†ú')
                ), m.text
              ))
            )
          ),
          e('div', { className: 'board-controls' },
            e('button', { onClick: () => setBoardMode('cursor'), className: `p-2 rounded-lg ${boardMode === 'cursor' ? 'bg-indigo-600 text-white' : 'text-slate-500'}` }, e('i', { className: 'fa-solid fa-arrow-pointer' })),
            e('button', { onClick: () => setBoardMode('pen'), className: `p-2 rounded-lg ${boardMode === 'pen' ? 'bg-indigo-600 text-white' : 'text-slate-500'}` }, e('i', { className: 'fa-solid fa-pen' })),
            e('button', { onClick: () => setBoardMode('eraser'), className: `p-2 rounded-lg ${boardMode === 'eraser' ? 'bg-indigo-600 text-white' : 'text-slate-500'}` }, e('i', { className: 'fa-solid fa-eraser' })),
            boardMode === 'pen' && ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#ffffff'].map(c => e('div', { key: c, className: `color-swatch ${penColor === c ? 'selected' : ''}`, style: { backgroundColor: c }, onClick: () => setPenColor(c) })),
            boardFullscreen && boardMode === 'cursor' && e('div', { className: 'flex-1 flex items-center bg-slate-50 rounded-xl px-3 py-1 ml-2' },
                e('textarea', { className: 'flex-1 bg-transparent text-sm outline-none font-bold text-slate-700 resize-none pt-1 overflow-hidden', rows: 1, placeholder: 'Î©îÎ™® ÏûÖÎ†•...', value: inputVal, onChange: (ev) => setInputVal(ev.target.value) }),
                e('button', { onClick: handleAdd, className: 'text-indigo-600 font-black px-2' }, '+')
            ),
            (boardMode === 'pen' || boardMode === 'eraser') && e('div', { className: 'flex-1 flex items-center justify-end gap-2 px-2' },
              e('input', { type: 'range', min: 1, max: boardMode === 'eraser' ? 300 : 100, value: boardMode === 'pen' ? penSize : eraserSize, onChange: (ev) => boardMode === 'pen' ? setPenSize(parseInt(ev.target.value)) : setEraserSize(parseInt(ev.target.value)), className: 'w-full' }),
              e('span', { className: 'text-[10px] font-bold text-slate-600 min-w-[24px] text-right' }, boardMode === 'pen' ? penSize : eraserSize)
            )
          )
        ),
        !boardFullscreen && e('div', { className: 'fixed bottom-6 left-0 right-0 px-5 max-w-md mx-auto z-[8000]' },
          e('div', { className: 'bg-slate-900 p-2 rounded-[2rem] shadow-2xl flex items-center gap-2' },
            e('select', { 
              className: 'text-[11px] font-black bg-slate-800 text-white px-3 py-3 rounded-2xl outline-none', 
              value: curTheme, onChange: (ev) => { if (ev.target.value === 'ADD_NEW_THEME_ACTION') openModal('THEME_ADD', null, ''); else setCurTheme(ev.target.value); }
            }, 
              e('option', { value: '', disabled: true }, 'ÌÖåÎßà ÏÑ†ÌÉù'),
              themes.map(t => e('option', { key: t, value: t }, t)),
              e('option', { value: 'Ïπ†Ìåê' }, '‚òÖ Ïπ†Ìåê'),
              e('option', { value: 'ADD_NEW_THEME_ACTION', className: 'text-indigo-400 font-bold' }, '+ ÌÖåÎßà Ï∂îÍ∞Ä')
            ),
            e('textarea', { className: 'flex-1 bg-transparent p-2 text-sm text-white outline-none resize-none pt-2 overflow-hidden', rows: 2, placeholder: 'Ï∂îÍ∞ÄÌï† ÎÇ¥Ïö©...', value: inputVal, onChange: (ev) => setInputVal(ev.target.value) }),
            e('button', { onClick: handleAdd, className: 'bg-indigo-500 text-white w-12 h-12 rounded-[1.2rem] font-black' }, '+')
          )
        )
      );
    };
    ReactDOM.render(e(App), document.getElementById('root'));
    window.closeModal = () => document.getElementById('external-modal').classList.remove('active');
  </script>
</body>
</html>
